# 一、CSS

## html网页渲染的基本过程

1．解析HTML文件，创建DOM树

2．解析CSS,形成CSS对象模型

3．将CSS与DOM合并，构建渲染树（renderingtree）

4．布局和绘制

- 布局将DOM和css样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型即渲染树。

**Repaint(重绘)**

重绘是改变不影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器会根据元素的新属性重新绘制一次(这就是重绘，或者说重新构造样式)，使元素呈现新的外观。**重绘不会带来重新布局，所以并不一定伴随重排。**

**Reflow（重排）**

渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。

**浏览器如何优化渲染？**

（1）将多次改变样式属性的操作合并成一次操作

（2）将需要多次重排的元素，position属性设为absolute或fixed，

这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。

（3）由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。

如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。

## 加载js脚本时，defer和async的区别

- 浏览器通过`HTTP`协议请求服务器，获取`HMTL`文档并开始从上到下解析，构建`DOM`；
- 在构建`DOM`过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；
- 样式文件下载完成后，构建`CSSDOM`；脚本文件下载完成后，解释并执行，然后继续解析文档构建`DOM`；
- 完成文档解析后，将`DOM`和`CSSDOM`进行关联和映射，最后将视图渲染到浏览器窗口 。

在这个过程中，脚本文件的下载和执行是与文档解析同步进行，也就是说，它会阻塞文档的解析，如果控制得不好，在用户体验上就会造成一定程度的影响。

```js
<script src="script.js"></script>

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

<script async src="script.js"></script>

有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。

<script defer src="myscript.js"></script>

有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。
```



## display:none、visibility:hidden和overflow:hidden的区别

**display:none:**

隐藏元素，不占网页中的任何空间，让这个元素彻底消失（看不见也摸不着）,由于会影响到网页的空间，所以会引起一次重排和重绘。

**visibility:hidden:**

他是把那个层隐藏了，也就是你看不到它的内容但是它内容所占据的空间还是存在的。（看不见但摸得到），该操作不会对页面有影响，所以只会引起一次重绘。

**overflow:hidden:**

让超出的元素隐藏（不占据网页空间），就是在设置该属性的时候他会根据你设置的宽高把多余的那部分剪掉，会引起一次重排和重绘。

## 盒模型

  CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距margin，边框border，填充padding，和实际内容content。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。



![Box-Model.jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef8eecacc7feef~tplv-t2oaga2asx-watermark.awebp)



`box-sizing: content-box`（W3C盒模型，又名标准盒模型）：元素的宽高大小表现为内容的大小。盒子模型的真实宽度是：width + padding

 `box-sizing: border-box`（IE盒模型，又名怪异盒模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。

## CSS3的新特性

- word-wrap 文字换行
- text-overflow 超过指定容器的边界时如何显示
- text-decoration 文字渲染
- text-shadow文字阴影
- gradient渐变效果
- transition过渡效果 transition-duration：过渡的持续时间
- transform拉伸，压缩，旋转，偏移等变换
- animation动画

transition和animation的区别：

  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。

## CSS选择器及其优先级

- !important
- 内联样式style=""
- ID选择器#id
- 类选择器/属性选择器/伪类选择器.class.active[href=""]
- 元素选择器/关系选择器/伪元素选择器html+div>span::after
- 通配符选择器*

| 选择器                   | 权重       |
| ------------------------ | ---------- |
| 继承或者 *               | 0，0，0，0 |
| 元素选择器（标签选择器） | 0，0，0，1 |
| 类选择器，伪类选择器     | 0，0，1，0 |
| ID选择器                 | 0，1，0，0 |
| 行内样式style=""         | 1，0，0，0 |
| ！important重要的        | 无穷大     |

## BFC

BFC（Block Formatting Context）**格式化上下文**，是Web页面中盒模型布局的CSS**渲染模式**，指一个**独立的渲染区域**或者说是一个**隔离的独立容器**。 

### BFC应用

1. 防止margin重叠

<img src="C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220309210438109.png" alt="image-20220309210438109" style="zoom:67%;" />

2. 清除浮动，防止高度塌陷

<img src="C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220309210538123.png" alt="image-20220309210538123" style="zoom:67%;" />

正常情况下是红色的大方块包裹着蓝色的小方块。但是由于蓝色的方块设置了浮动，脱离了文档流，所以红色的只剩下边距

通过给父容器添加overflow：hidden 触发BFC  从而达到了如下图所示的效果

![image-20220309210708298](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220309210708298.png)

3. 自适应两（多）栏布局

<img src="C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220309211001756.png" alt="image-20220309211001756" style="zoom:67%;" />

红色元素会被蓝色的浮动元素覆盖。给红色元素添加overflow:hidden  触发BFC，两个元素不互相干扰，实现了自适应两栏布局

<img src="C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220309210933396.png" alt="image-20220309210933396" style="zoom:67%;" />

4. 防止字体环绕

### 触发BFC条件

- 根元素<html>
- float的值不为none
- overflow的值不为visible
- display的值为inline-block、table-cell、table-caption
- position的值为absolute、fixed

### BFC的特性

- 内部的Box会在垂直方向上一个接一个的放置。
- 垂直方向上的距离由margin决定
- bfc的区域不会与float的元素区域重叠。
- 计算bfc的高度时，浮动元素也参与计算
- bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

## 浏览器渲染机制、重绘、重排

网页生成过程：

- `HTML`被HTML解析器解析成`DOM` 树
- `css`则被css解析器解析成`CSSOM `树
- 结合`DOM`树和`CSSOM`树，生成一棵渲染树(`Render Tree`)
- 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成
- 将布局绘制（`paint`）在屏幕上

**重排(也称回流):** 当`DOM`的变化影响了元素的几何信息(`DOM`对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 触发：

1. 添加或者删除可见的DOM元素
2. 元素尺寸改变——边距、填充、边框、宽度和高度
2. 页面首次渲染
2. 浏览器窗口大小发生改变
2. 激活CSS伪类（例如：:hover）

一些常用且会导致回流的属性和方法：

- `clientWidth、clientHeight、clientTop、clientLeft`
- `offsetWidth、offsetHeight、offsetTop、offsetLeft`
- `scrollWidth、scrollHeight、scrollTop、scrollLeft`
- `scrollIntoView()、scrollIntoViewIfNeeded()`
- `getComputedStyle()`
- `getBoundingClientRect()`
- `scrollTo()`

**重绘：** 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 触发：

- 改变元素的`color、background、box-shadow`等属性

重排优化建议：

1. 样式集中修改
2. 缓存需要修改的`DOM`元素
3. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
4. 动画开始`GPU`加速，`translate`使用`3D`变化
5. 设置display: none，操作结束后再把它显示出来。

`transform` 不重绘，不回流 是因为`transform`属于合成属性，对合成属性进行`transition/animate`动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。

## div水平居中

> [10种水平垂直居中对齐方式（史上最全） - 简书 (jianshu.com)](https://www.jianshu.com/p/907f99004c3e)

1. 行内元素

```css
.parent {
    text-align: center;
}
//text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。所以是设置给父类的
```

2. 块级元素

```css
.son {
    margin: 0 auto;
}
```

3. flex布局

```css
.parent {
    display: flex;
    justify-content: center;
}
```

4. 绝对定位定宽

```css
.son {
    position: absolute;
    width: 宽度;
    left: 50%;
    margin-left: -0.5*宽度
}
```

5. 绝对定位不定宽

```css
.son {
    position: absolute;
    left: 50%;
    transform: translate(-50%, 0);
}
```

6. left/right: 0

```css
.son {
    position: absolute;
    width: 宽度;
    left: 0;
    right: 0;
    margin: 0 auto;
}
```

## div垂直居中

1. 行内元素

```css
.parent {
    height: 高度;
}
.son {
    line-height: 高度;
}
```

解决方案：

- **让文字的行高等于盒子的高度，就可以让文字在当前盒子内垂直居中。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/9c556ac433af41b5888802765754b8f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1Z2Vuc3Rlcm5fUVhM,size_16,color_FFFFFF,t_70#pic_center)

简单理解：

- 行高的上空隙和下空隙把文字挤到中间了
- 如果是行高小于盒子高度，文字会偏上，如果行高大于盒子高度，则文字偏下

2. table

```css
.parent {
  display: table;
}
.son {
  display: table-cell;
  vertical-align: middle;
}
```

3. flex

```css
.parent {
    display: flex;
    align-items: center;
}
```

4. 绝对定位定高

```css
.son {
    position: absolute;
    top: 50%;
    height: 高度;
    margin-top: -0.5高度;
}
```

5. 绝对定位不定高

```css
.son {
    position: absolute;
    top: 50%;
    transform: translate( 0, -50%);
}
```

6. top/bottom: 0;

```css
.son {
    position: absolute;
    height: 高度;
    top: 0;
    bottom: 0;
    margin: auto 0;
}
```

## 绝对定位和相对定位

- `absolute` 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。
  - 特点：
    - 如果没有祖先元素，或者祖先元素没定位，则以浏览器为准进行定位(Document 文档)

    - 如果祖先元素父级有定位(相对、绝对、固定定位)，则以最近一级的有定位祖先元素为参考点移动位置

    - 绝对定位不再占用原先的位置（脱标）

- `fixed` **固定定位**是元素**固定于浏览器的可视区的位置**
  - 特点：
    - 以浏览器的可视窗口为参照点移动元素
    - 跟父元素没有任何关系
    - 不随滚动条滚动
    - 固定定位**不再占有原先的位置**(脱标)
- `relative`相对定位是元素在移动位置的时候，是相对于它原来的位置来说的
  - 特点：
    - 它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）

    - 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待。（不脱标，继续保留原来位置）

    - 因此，相对定位并没有脱标，它最典型的应用是给绝对定位当爹的。


共同点：改变行内元素的呈现方式，都脱离了文档流；不同点：absolute的”根元素“是可以设置的，fixed的“根元素”固定为浏览器窗口

## display

display 有哪些值？说明他们的作用。

| 值               | 作用                                                       |
| ---------------- | ---------------------------------------------------------- |
| **block**        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。       |
| block            | 让元素显示出现   对比display:none                          |
| **none**         | 元素不显示，并从文档流中移除。                             |
| **inline**       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 |
| **inline-block** | 行内块元素，默认宽度为内容宽度，可以设置宽高，同行显示。   |
| **flex**         | 设置flex布局                                               |
| list-item        | 像块类型元素一样显示，并添加样式列表标记。                 |
| table            | 此元素会作为块级表格来显示。                               |
| inherit          | 规定应该从父元素继承display属性的值。                      |

## flex布局

- flex布局，称为弹性布局，用来给盒状的模型提供最大的灵活性，任何一个容器都可以指定为felx布局
- 采用 Flex 布局的元素，称为 `Flex 容器`（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 `Flex 项目`（flex item），简称“项目”。
  - 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。
  - 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = flex布局

![flex.jpeg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef8eecacd1b3fc~tplv-t2oaga2asx-watermark.awebp)

1. 父元素属性

| 属性名              | 属性值                                                | 备注                                                         |
| ------------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| display             | flex                                                  | 定义了一个flex容器，它的直接子元素会接受这个flex环境         |
| **flex-direction**  | row,row-reverse,column,column-reverse                 | 决定主轴的方向                                               |
| flex-wrap           | nowrap,wrap,wrap-reverse                              | 如果一条轴线排不下，如何换行                                 |
| flex-flow           | [flex-direction] , [flex-wrap]                        | 是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap` |
| **justify-content** | flex-start,flex-end,center,space-between,space-around | 设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式         |
| **align-items**     | flex-start,flex-end,center,baseline,stretch           | 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式         |

2. 子元素属性

| 属性名      | 属性值                                           | 备注                                                         |
| ----------- | ------------------------------------------------ | ------------------------------------------------------------ |
| flex        | int                                              | 子项目占的份数                                               |
| order       | [int]                                            | 默认情况下flex order会按照书写顺训呈现，可以通过order属性改变，数值小的在前面，还可以是负数。 |
| flex-grow   | [number]                                         | 设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间 |
| flex-shrink | [number]                                         | 设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间 |
| flex-basis  | [length], auto                                   | 设置或检索弹性盒伸缩基准值                                   |
| align-self  | auto,flex-start,flex-end,center,baseline,stretch | 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置 |

通过子元素的flex属性实现圣杯布局

```html
<style>
        .father {
            display: flex;
            width: 900px;
            height: 100px;
            background-color: antiquewhite;
            margin: 0 auto;
        }

        .left {
            width: 50px;
            height: 100px;
            background-color: red;
        }

        .right {
            width: 50px;
            height: 100px;
            background-color: blue;
        }

        .middle {
            flex: 1;
            background-color: black;
        }
    </style>
</head>

<body>
    <div class="father">
        <div class="left"></div>
        <div class="middle"></div>
        <div class="right"></div>
    </div>
    <body>

```

## 让元素消失

visibility:hidden、display:none、z-index=-1、opacity：0

1. opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发
2. visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件
3. display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉
4. z-index=-1置于其他元素下面

## 清除浮动

### 为什么要清除浮动

- 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7ae44f5681f549a99c1b7d1f45e5205b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1Z2Vuc3Rlcm5fUVhM,size_16,color_FFFFFF,t_70#pic_center)

- 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响
- 理想中的状态，让子盒子撑开父亲，有多少孩子，我父盒子就有多高

### 清除浮动的本质

- 清除浮动的本质是**清除浮动元素造成的影响**
- 如果父盒子本身有高度，**则不需要清除浮动**
- 清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了。

### 清除浮动的方法

1. 额外标签法
   - 额外标签法会在浮动元素末尾添加一个空的标签,例如：
   - 例如<div style="clear:both"></div>，或者其他标签（如</br>等）

   - 注意：要求这个新的空标签必须是块级元素

   - 优点：通俗易懂，书写方便

   - 缺点：添加许多无意义的标签，结构化较差

   - 实际工作可能会遇到,但是不常用

2. 给父元素添加 `overflow:hidden` 或者 `auto` `scroll`样式，触发BFC。
   - 优点：代码简洁
   - 缺点：无法显示溢出的部分

```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
</div>
.container{
    width: 300px;
    background-color: #aaa;
    overflow:hidden;
    zoom:1;   /*IE6*/
}
```

3. **after伪元素法**

:after 方式是额外标签法的升级版。也是给父元素添加

```css
.clearfix:after {
    content: "";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}
.clearfix {
      /* IE6,7专有*/
      *zoom : 1; 
}
```

**推荐**使用第三种方法，不会在页面新增div，文档结构更加清晰。

## calc函数

calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。

```css
#div1 {
    position: absolute;
    left: 50px;
    width: calc( 100% / (100px * 2) );
    //兼容写法
    width: -moz-calc( 100% / (100px * 2) );
    width: -webkit-calc( 100% / (100px * 2) );
    border: 1px solid black;
}
```

注意点：

- 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px);
- calc()函数支持 "+", "-", "*", "/" 运算;
- 对于不支持 calc() 的浏览器，整个属性值表达式将被忽略。不过我们可以对那些不支持 calc()的浏览器，使用一个固定值作为回退。

## 移动端rem

rem官方定义『The font size of the root element』，即根元素的字体大小。**rem是一个相对的CSS单位，1rem等于html元素上font-size的大小。**所以，我们只要设置html上font-size的大小，就可以改变1rem所代表的大小。

```js
(function () {
    var html = document.documentElement;
    function onWindowResize() {
        html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
    }
    window.addEventListener('resize', onWindowResize);
    onWindowResize();
})();
```

## 移动端1px

一般来说，在PC端浏览器中，设备像素比（dpr）等于1，1个css像素就代表1个物理像素；但是在retina屏幕中，dpr普遍是2或3，1个css像素不再等于1个物理像素，因此比实际设计稿看起来粗不少。

1. 伪元素+scale

```html
<style>
    .box{
        width: 100%;
        height: 1px;
        margin: 20px 0;
        position: relative;
    }
    .box::after{
        content: '';
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 1px;
        transform: scaleY(0.5);
        transform-origin: 0 0; 
        background: red;
    }
</style>

<div class="box"></div>

```

2. border-image

```css
div{
    border-width: 1px 0px;
    -webkit-border-image: url(border.png) 2 0 stretch;
    border-image: url(border.png) 2 0 stretch;
}
```

## 两边宽度固定中间自适应的三栏布局

三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。

（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。

（2）**利用flex布局的方式，左右两栏的宽度分别设置为100px和200px，中间一栏增长系数设置为1**

（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。

（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。

（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。

圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。

### 圣杯布局

```html
<style>
body{
    min-width: 550px;
}
#container{
    padding-left: 200px;
    padding-right: 150px;
}
#container .column{
    float: left;
}
#center{
    width: 100%;
}
#left{
    width: 200px;
    margin-left: -100%;
    position: relative;
    right: 200px;
}
#right{
    width: 150px;
    margin-right: -150px;
}
</style>
<div id="container">
    <div id="center" class="column">center</div>
    <div id="left" class="column">left</div>
    <div id="right" class="column">right</div>
</div>
```



![Layout.gif](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef8eecace7c294~tplv-t2oaga2asx-watermark.awebp)



### 双飞翼布局

```html
<style>
body {
    min-width: 500px;
}
#container {
    width: 100%;
}
.column {
    float: left;
}
#center {
    margin-left: 200px;
    margin-right: 150px;
}
#left {
    width: 200px;
    margin-left: -100%;
}
#right {
    width: 150px;
    margin-left: -150px;
}
</style>
<div id="container" class="column">
    <div id="center">center</div>
</div>
<div id="left" class="column">left</div>
<div id="right" class="column">right</div>
```

## 伪类和伪元素

css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分。

![before-after.jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef8eecad345c02~tplv-t2oaga2asx-watermark.awebp)

### 伪类

伪类存在的意义是为了通过选择器找到那些不存在DOM树中的信息以及不能被常规CSS选择器获取到的信息。

1. 获取不存在与DOM树中的信息。比如a标签的:link、visited等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取；
2. 获取不能被常规CSS选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。

![weilei.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef8eecad4f1adb~tplv-t2oaga2asx-watermark.awebp)

### 伪元素

伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：`::before`，`::after`，`::first-line`，`::first-letter`，`::selection`、`::placeholder`等

> 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。

### ::after和:after的区别

在实际的开发工作中，我们会看到有人把伪元素写成`:after`，这实际是 CSS2 与 CSS3新旧标准的规定不同而导致的。

CSS2 中的伪元素使用1个冒号，在 CSS3 中，为了区分伪类和伪元素，规定伪元素使用2个冒号。所以，对于 CSS2 标准的老伪元素，比如`:first-line`，`:first-letter`，`:before`，`:after`，写一个冒号浏览器也能识别，但对于 CSS3 标准的新伪元素，比如::selection，就必须写2个冒号了。

## 使用 CSS 画一个三角形

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .triggle {
            width: 0px;
            height: 0px;
            border-width: 100px;
            border-style: dotted dotted solid dotted;
            border-color: transparent transparent red transparent;
        }
    </style>
</head>

<body>
    <div class="triggle"></div>
</body>

</html>
```

![image-20220223184324076](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220223184324076.png)

```css
width: 200px;
```

![image-20220223184409640](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220223184409640.png)

```css
 border-color: transparent transparent red transparent;
```

<img src="C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220223184541923.png" alt="image-20220223184541923" style="zoom:50%;" />

## CSS画圆半圆扇形三角梯形

```css
div{
    margin: 50px;
    width: 100px;
    height: 100px;
    background: red;
}
/* 半圆 */
.half-circle{
    height: 50px;
    border-radius: 50px 50px 0 0;
}
/* 扇形 */
.sector{
    border-radius: 100px 0 0;
}
/* 三角 */
.triangle{
    width: 0px;
    height: 0px;
    background: none;
    border: 50px solid red;
    border-color: red transparent transparent transparent;
}
/* 梯形 */
.ladder{
    width: 50px;
    height: 0px;
    background: none;
    border: 50px solid red;
    border-color: red transparent transparent transparent;
}
```

## CSS 动画

- CSS动画（CSS Animations）是为层叠样式表建议的允许可扩展标记语言（XML）元素使用CSS的动画的模块
- 即指元素从一种样式逐渐过渡为另一种样式的过程
- 常见的动画效果有很多，如平移、旋转、缩放等等，复杂动画则是多个简单动画的组合
- css实现动画的方式，有如下几种：
  - transition 实现渐变动画
  - transform 转变动画
  - animation 实现自定义动画

## CSS中 link 和@import 的区别是？

- link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载
- import只在IE5以上才能识别，而link是HTML标签，无兼容问题
- link方式的样式的权重 高于@import的权重.

## 画一条0.5px的线

- 采用transform: scale()的方式

```css
div {
            height: 1px;
            background-color: red;
            transform: scale(50%);
        }
```

## 块元素和行元素

- 块元素：独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度
- 行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。

# 二、JS

## JS数据类型

JS基本有5种简单数据类型：String，Number，Boolean，Null，Undefined。引用数据类型：Object，Array，Function。

## 判断数据类型的方法

在写业务逻辑的时候，经常要用到JS数据类型的判断，面试常见的案例深浅拷贝也要用到数据类型的判断。

### typeof

- 返回的是数据类型的字符串表达	
- 可以判断undefined/Number/String/Boolean/**function**
- 不能区分把null   object   array区分开   （都是object）

```js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof undefined);       // undefined
console.log(typeof []);              // object 
console.log(typeof {});              // object
console.log(typeof function(){});    // function
console.log(typeof null);            // object
```

优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object

### instanceof

- 表达式: A instanceof B
- 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false

```js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false  
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
```

优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断

### Object.prototype.toString.call()

```js
var toString = Object.prototype.toString;
 
console.log(toString.call(2));                      //[object Number]
console.log(toString.call(true));                   //[object Boolean]
console.log(toString.call('str'));                  //[object String]
console.log(toString.call([]));                     //[object Array]
console.log(toString.call(function(){}));           //[object Function]
console.log(toString.call({}));                     //[object Object]
console.log(toString.call(undefined));              //[object Undefined]
console.log(toString.call(null));                   //[object Null]
```

优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用

## var,let,const的区别

`let` 为 `ES6` 新添加申明变量的命令，它类似于 `var`，但是有以下不同：

- 变量提升方面：
  - var 声明的变量允许变量提升
  - let和const不存在变量提升
- 块级作用域方面
  - var不存在块级作用域
  - let和const存在块级作用域
- 声明方面
  - var允许重复声明
  - let和const在同一作用域中不允许重复声明
  - const变量声明一个只读的常量，不允许修改，声明的时候一定要赋值，不然会报错

## null和undefined区别

Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法：

- 变量被声明了，但没有赋值时，就等于undefined。
- 调用函数时，应该提供的参数没有提供，该参数等于undefined。
- 对象没有赋值的属性，该属性的值为undefined。
- 函数没有返回值时，默认返回undefined。

Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法

- 作为对象原型链的终点。
- 将对象回收为垃圾对象

## 正则表达式

正则表达式是一种用来匹配字符串的强有力的武器

它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的

## 遍历对象的方式

[(29条消息) JS中三种主要的遍历对象的方法：for in、Object.keys、Object.getOwnProperty_tomy123456123456的博客-CSDN博客_遍历对象的方法](https://blog.csdn.net/tomy123456123456/article/details/81633548?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_aa&utm_relevant_index=5)

- for in：主要用于遍历对象的可枚举属性，包括自有属性、继承自原型的属性
- Object.keys：此方法返回一个数组，元素均为对象自有可枚举的属性
- Object.getOwnProperty主要用于返回对象的自有属性，包括可枚举和不可枚举的属性，不包括继承自原型的属性。

## 定义函数的方法

1. 函数声明

```js
//ES5
function getSum(){}
function (){}//匿名函数
//ES6
()=>{}
```

2. 函数表达式

```js
//ES5
var getSum=function(){}
//ES6
let getSum=()=>{}
```

3. 构造函数

```js
const getSum = new Function('a', 'b' , 'return a + b')
```

## JS作用域的理解

> JS中的作用域分为两种：全局作用域和函数作用域。函数作用域中定义的变量，只能在函数中调用，外界无法访问。没有块级作用域导致了if或for这样的逻辑语句中定义的变量可以被外界访问，因此ES6中新增了let和const命令来进行块级作用域的声明。

更多作用域的了解可以看[JS作用域](https://link.juejin.cn?target=http%3A%2F%2Fxieyufei.com%2F2016%2F09%2F21%2FJS-Variate-Scope.html)

1. 理解

- 就是一块"地盘", 一个代码段所在的区域
- 它是静态的(相对于上下文对象), 在编写代码时就确定了

2. 分类

- 全局作用域
- 函数作用域
- 没有块作用域(ES6有了) -->(java语言也有)

3. 作用

- **隔离变量，不同作用域下同名变量不会有冲突**

4. 作用域数量

   n+1 ， n：函数定义的个数

### 作用域链

1. 理解

- 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
- 查找变量时就是沿着作用域链来查找的

```js
var x = 10;
function fn() { console.log(x); }
function show(f) {
    var x = 20;
    f();
}
show(fn); //输出10
//作用域是静态的  在函数定义的时候就确定了 不会因为函数的调用改变

var fn = function () {
 console.log(fn)
}
fn()

var obj = { //对象变量不能产生局部作用域,所以会找到全局去,导致报错
 fn2: function () {
  console.log(fn2)
  //console.log(this.fn2)
 }
}
obj.fn2()
```

## JS执行上下文

**函数执行上下文只有再函数调用的时候才会产生！**

1. 在全局代码执行前, JS引擎就会创建一个栈（先进后出）来存储管理所有的执行上下文对象
2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)-->`所以栈底百分百是[window]`
3. 在函数执行上下文创建后, 将其添加到栈中(压栈)
4. 在当前函数执行完后,将栈顶的对象移除(出栈)
5. 当所有的代码执行完后, 栈中只剩下window
6. `上下文栈数==函数调用数+1`
7. 函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖

### 相关面试题

```js
*/
function a() {}
var a
console.log(typeof a) // 'function'
//函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖

/*
测试题2:
*/
if (!(b in window)) {
 var b = 1
}
console.log(b) // undefined

/*
测试题3:
*/
var c = 1
function c(c) {
 console.log(c)
 var c = 3 //与此行无关
}
c(2) // 报错  c is not a function
```

## JS作用域和执行上下文的区别

1. 区别1（创建时间）

- 全局作用域之外，每个函数都会创建自己的作用域，作用域再函数定义的时候就已经确当了，而不是再函数调用的时候确定的
- 全局上下文是在全局作用域确定之后，js代码马上执行之前创建
- 函数执行上下文环境是在调用函数时，函数体代码执行之前创建

2. 区别2 （静动态）

- 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
- 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放

## This

This 是**执行上下文中的一个属性**，它指向最后一次**调用这个方法的对象**。在实际开发中，this 的指向可以通过四种调用模式来判断。

​    1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。

​    2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。

​    3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。

​    4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

## call,apply和bind区别

三个函数的作用都是将函数绑定到上下文中，用来改变函数中this的指向；三者的不同点在于语法的不同。

```js
fun.call(thisArg, arg1[, arg2[, ...]]])
fun.apply(thisArg, [argsArray])
```

- `call apply bind`第一个参数都是指向所指的对象
- `apply`和`call`的区别是`call`方法接受的是若干个参数列表，而`apply`接收的是一个包含多个参数的数组。
- 而bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。

```js
var bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])
bindFn()
```

Demos：

```js
var name = 'window';
var sayName = function (param) {
    console.log('my name is:' + this.name + ',my param is ' + param)
};
//my name is:window,my param is window param
sayName('window param')

var callObj = {
    name: 'call'
};
//my name is:call,my param is call param
sayName.call(callObj, 'call param');


var applyObj = {
    name: 'apply'
};
//my name is:apply,my param is apply param
sayName.apply(applyObj, ['apply param']);

var bindObj = {
    name: 'bind'
}
var bindFn = sayName.bind(bindObj, 'bind param')
//my name is:bind,my param is bind param
bindFn();
```

## 箭头函数和普通函数的区别

- **不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。**
- **不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替**
- 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。
- **在箭头函数中，this引用的是定义箭头函数的上下文！！箭头函数中的 this 会保留定义该函数时的上下文**。（实际上：**箭头函数没有自己的this，它的this是继承而来，默认指向在定义它时所处的对象(宿主对象)。**）所以call() apply() bind() 对于箭头函数来说知只是传入参数，对它的this没有影响

## 闭包的理解

1. 如何产生闭包？

​	当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包

2. 闭包到底是什么？

  \- 闭包是一个存在内部函数的引用关系

3. 产生闭包的条件？

   - 函数嵌套
   - 内部函数引用了外部函数的数据

   - 执行外部函数，不一定要调用内部函数，内部函数只要有定义就可以了

4. 常见的闭包

   - 将函数作为一个函数的返回值

   - 将函数作为实参传递给另一个函数调用

   - 定义JS模块：

     - 具有特定功能的js文件

     - 将所有的数据和功能都分装在一个函数内部（私有的）

     - 只向外暴露一个包含n个方法的对象或函数

     - 模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能

     - ```js
       //js方法一 这种好一点
       (function () {
           var msg = 'my atguigu'
           function doSomething() {
               console.log('doSOmething() ' + msg.toUpperCase())
           }
           function doOtherthing() {
               console.log('doSOmething() ' + msg.toLowerCase())
           }
           window.myModule2 = {
               doSomething: doSomething,
               doOtherthing: doOtherthing
           }
       })()
       // 立即执行函数
       //html
       myModule2.doSomething()
       myModule2.doOtherthing()
       ```

5. 闭包的作用
   - **使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的声明周期）**
   - **让函数外部可以操作（读写）到函数内部的数据（变量/函数）**

6. 问题

   - 函数执行完后，函数内部声明的局部变量是否还存在？

     - 一般情况下不存在

     - 只有存在于闭包中的局部变量存在，在闭包里面。在上面的例子里面。fn1执行完以后，a还存在于闭包里面。而fn2和fn3都释放了，因为没有被内部函数引用。但是fn3对应的函数对象还存在，因为被f引用了。
     - 如果把 var f = fn3() 修改为fn3() ，则闭包就不存在了。因为这个时候就没有引用指向，内部函数就称为垃圾对象了。


   - 在函数外部能直接访问函数内部的局部变量吗？

     不能。但是我们可以通过闭包让外部操作它

7. 闭包的产生和死亡

   - 产生：在嵌套函数内部定义执行完成时就产生了（不是调用）

   - 死亡：在嵌套的内部函数成为垃圾对象时

8. 闭包的缺点：
   - 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
   - 容易造成内存泄漏

## 数组去重

```js
let arr = [1,'1',2,'2',1,2,'x','y','f','x','y','f'];
function unique1(arr){
	let result = [arr[0]];
	for (let i = 1; i < arr.length; i++) {
		let item = arr[i];
		if(result.indexOf(item) == -1){
			result.push(item);
		}
	}
	return result;
}
console.log(unique1(arr));
```

更多JS去重的方法[JS数组去重](https://link.juejin.cn?target=http%3A%2F%2Fxieyufei.com%2F2017%2F09%2F02%2FJS-Array-Remove-Duplicate.html)

## ==和===区别

- ==， 两边值类型不同的时候，要先进行类型转换，再比较
- ===，不做类型转换，类型不同的一定不等。

==类型转换过程：

1. 如果类型不同，进行类型转换
2. 判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .
3. 判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number
4. 判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断
5. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断

经典面试题：[] == ![] 为什么是true

转化步骤：

1. !运算符优先级最高，`![]`会被转为为false，因此表达式变成了：`[] == false`
2. 根据上面第(4)条规则，如果有一方是boolean，就把boolean转为number，因此表达式变成了：`[] == 0`
3. 根据上面第(5)条规则，把数组转为原始类型，调用数组的toString()方法，`[]`转为空字符串，因此表达式变成了：`'' == 0`
4. 根据上面第(3)条规则，两边数据类型为string和number，把空字符串转为0，因此表达式变成了：`0 == 0`
5. 两边数据类型相同，0==0为true

## 深拷贝和浅拷贝

### 什么是深浅拷贝

如何区分深拷贝与浅拷贝？简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明是浅拷贝，如果B没变，那就是深拷贝。深入点来说，就是B复制了A，如果**B复制的是A的引用，那就是浅拷贝，如果B复制的是A的本体**，那就是深拷贝。在深入了解深拷贝和浅拷贝之前，我们先得了解堆栈和数据类型。

深拷贝与浅拷贝出现的根源就在于引用数据类型。当我们定义a=[0,1,2,3,4]，b=a时，其实复制的是a的引用地址，而并非堆里面的值。**因为指向了相同的地址**，所以当我们更改a时b会改变，更改b时a也会改变，这就是浅拷贝。

![image-20220228190846699](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220228190846699.png)

但很多时候我们并不希望a和b直接互相影响，这时就需要想下图这样，单独为b也开辟一块堆内存，这就用到了深拷贝。

![image-20220228190852752](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220228190852752.png)

浅拷贝

```JS
function simpleClone(obj) {
    var result = {};
    for (var i in obj) {
        result[i] = obj[i];
    }
    return result;
}
```

### 如何实现深拷贝

> [(29条消息) 浅谈深拷贝和浅拷贝（js）_GuoZebin的博客-CSDN博客_深拷贝和浅拷贝](https://blog.csdn.net/qq_41635167/article/details/82943223?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17.pc_relevant_antiscan&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17.pc_relevant_antiscan&utm_relevant_index=24)

对于Object和Array两种类型可以采用以下两种方法

function、Date、RegExp 和Error无法复制，因为它们有特殊的构造函数。

**1. 迭代递归法**

**for...in...法**

对对象进行迭代操作，对它的每个值进行递归深拷贝。

```js
function isObject(o) {
    return (typeof o === 'object' || typeof o === 'function') && o !== null
}
// 迭代递归法：深拷贝对象与数组
function deepClone(obj) {
    if (!isObject(obj)) {
        throw new Error('obj 不是一个对象！')
        //throw语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个catch块。如果调用者函数中没有catch块，程序将会终止。
        //通过Error构造器我们可以创建一个错误对象，当程序运行出错时，Error的实例对象就会被抛出。
        //new Error([message[, fileName[, lineNumber]]])
        //message
		//可选， 描述错误的信息, 类型为一个字符串，如果不是字符串则会调用其		
        //toString()fileName可选，被创建的Error对象的fileName属性值，默认为调用Error构造器的文件名
		//lineNumber可选， 默认为调用Error构造器的文件行号      
    }
 
    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [] : {}
    for (let key in obj) {
        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
    }
 
    return cloneObj
}

var a = {
    name: 'fangyao',
    address: {
        city: 'Hefei',
        province: 'Anhui'
    },
    hobbies: ['music', 'singing', 'sleep']
}
var e = deepClone(a)
e.name = 'Huxiao'
console.log(e)
console.log(a)
```

结果

![image-20220228191050776](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220228191050776.png)

**2. 序列化反序列化法**

**使用JSON对象的parse和stringify方法来实现深拷贝**

```js
function deepClone(obj){
    let _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}    
let a=[0,1,[2,3],4],
    b=deepClone(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);
//JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象；序列化的作用是存储(对象本身存储的只是一个地址映射，如果断电，对象将不复存在，因此需将对象的内容转换成字符串的形式再保存在磁盘上 )和传输
```

它也只能深拷贝对象和数组，对于其他种类的对象，会失真。这种方法比较适合平常开发中使用，因为通常不需要考虑对象和数组之外的类型。

## 防抖和节流

- 函数防抖是指**在事件被触发 n 秒后再执行回调**，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
- 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。
- 节流与防抖的前提都是某个行为持续地触发，不同之处只要判断是**要优化到减少它的执行次数还是只执行一次就行。**
- 节流例子，像dom的拖拽，如果用防抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多。
- 防抖例子，像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。

![debounce_throttle.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef8eecace52a44~tplv-t2oaga2asx-watermark.awebp)

防抖

[防抖使用详情](C:\Users\fy\Desktop\web-projects\leetcode\防抖.html)

```js
function debounce(fn, delay) {
  let timer = null;
  return function () {
    let context = this
     // 如果没有这一行，则fn里面的this在被调用的时候会指向windows
    if (timer) clearTimeout(timer);
      // 由于setTimeout中的回调函数this指向window，（严格模式下是undefined）
      // 而我们希望的是debounce调用的函数可以指向原来的this 而不是windows
      // 这里需要修改setTimeout回调函数中的this
    timer = setTimeout(() => {
      fn.apply(context, arguments);
    }, delay);
  }
}
```

节流

[节流使用详情](C:\Users\fy\Desktop\web-projects\leetcode\节流.html)

```js
//时间戳版本
function throttle(func, wait) {
    var previous = 0;
    // 前面这两句只有在第一次click的时候才会调用
    // 因为一旦触发了click  就只调用了一次throttle后，就返回了function
    /* 相当于box.addEventListener("click",function () {
            var now = Date.now();
            var context = this;
            var args = arguments;
            // console.log(previous)
            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        })
        */
    return function () {
        var now = Date.now();
        var context = this;
        var args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}

//下面这个没理解透彻
function throttle(fn, cycle) {
  let start = Date.now();
  let now;
  let timer;
  return function () {
    let context = this
    now = Date.now();
    clearTimeout(timer);
    if (now - start >= cycle) {
      fn.apply(context, arguments);
      start = now;
    } else {
      timer = setTimeout(() => {
        fn.apply(context, arguments);
      }, cycle);
    }
  }
}
```

```html
//完整版
<body>
    <button id="btn1">点我防抖</button>
    <button id="btn2">点我节流</button>
</body>
<script>
    const btn1 = document.getElementById('btn1')
    btn1.addEventListener("click", debounce(say, 2000))
    const btn2 = document.getElementById('btn2')
    btn2.addEventListener("click", throttle(say, 200))
    function say() {
        console.log("我被点啦！")
    }
    function debounce(func, time) {
        var timer = null
        return function () {
            var that = this
            if (timer) clearTimeout(timer)
            timer = setTimeout(() => {
                func.apply(that, arguments)
            }, time)
        }
    }

    function throttle(func, time) {
        var preTime = Date.now()
        return function () {
            var that = this
            var nowTime = Date.now()
            if (nowTime - preTime > time) {
                func.apply(that, arguments)
                preTime = nowTime
            }
        }
    }
</script>
```

## 图片懒加载和预加载

- 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
- 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

### 图片懒加载实现

<img src="C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220312102724407.png" alt="image-20220312102724407" style="zoom:67%;" />

```js
//获取图片相对可视区顶部的距离
getBoundingClientRect()//获取元素的大小及相对视口的位置
var bound = el.getBoundingClientRect()//el传入的是图片，获取到图片的相对视口的位置
bound.top//这个就是图片上部到可视区顶部的距离

//获取可视区高度
ver ClientHeight = window.innerHeight

//完整代码
var imgs = document.querySelectorAll('img');

//用来判断bound.top<=clientHeight的函数，返回一个bool值
function isIn(el) {
    var bound = el.getBoundingClientRect();
    var clientHeight = window.innerHeight;
    return bound.top <= clientHeight;
} 
//检查图片是否在可视区内，如果不在，则加载
function check() {
    Array.from(imgs).forEach(function(el){
        if(isIn(el)){
            loadImg(el);
        }
    })
}
function loadImg(el) {
    if(!el.src){
        var source = el.dataset.src;
        el.src = source;
    }
}
window.onload = window.onscroll = function () { //onscroll()在滚动条滚动的时候触发
    check();
}
```



## cookie,sessionStorage和localStorage

- cookie用来保存登录信息，大小限制为4KB左右
- localStorage是Html5新增的，用于本地数据存储，保存的数据没有过期时间，一般浏览器大小限制在5MB
- sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同，页面关闭后会被清空。

| 名称           | 生命期                                                       | 大小限制 | 与服务器通信                                                 |
| -------------- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| cookie         | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 4KB      | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 |
| localStorage   | 除非被清除，否则永久保存                                     | 5MB      | 仅在浏览器中保存，不与服务器通信                             |
| sessionStorage | 仅在当前会话下有效，关闭页面或浏览器后被清除                 | 5MB      | 仅在浏览器中保存，不与服务器通信                             |

## 0.1+0.2!=0.3怎么处理

[(29条消息) 在js中为什么0.1+0.2不等于0.3_siyi_blog的博客-CSDN博客_js0.1+0.2不等于0.3](https://blog.csdn.net/siyi_blog/article/details/84388403?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_aa&utm_relevant_index=10)

原因在于在**JS中采用的IEEE 754的双[精度](https://so.csdn.net/so/search?q=精度&spm=1001.2101.3001.7020)标准**，计算机内部存储数据的编码的时候，**0.1在计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1**。当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于0.3 的原因。

另外要注意，不是所有浮点数都有舍入误差。**二进制能精确地表示位数有限且分母是2的倍数的小数**，比如0.5，0.5在计算机内部就没有舍入误差。所以0.5 + 0.5 === 1

最好的方法就是我们想办法规避掉这类小数计算时的精度问题就好了，那么最常用的方法就是将浮点数转化成整数计算。因为整数都是可以精确表示的。

通常的解决办法 就是 把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。一般都用 1000 就行了。

把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完成后再进行降级（除以10的n次幂），即：

```js
(0.1*1000+0.2*1000)/1000==0.3
//true
```

更多关于浮点数精度处理请看[JS中浮点数精度问题](https://link.juejin.cn?target=http%3A%2F%2Fxieyufei.com%2F2018%2F03%2F07%2FJS-Decimal-Accuracy.html)

## Promise

- promise是异步编程的一种解决方案：

  -   从语法上讲，promise是一个对象，从它可以获取异步操作的消息；

  -   从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。

- promise有三种状态：

  -   pending（等待态），fulfiled（成功态），rejected（失败态）；


  -   Promise有以上三种状态，只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态


  -   状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆，只能由 pending变成fulfilled或者由pending变成rejected


- Promise 运行时机 
  - 创造promise实例后，它本身的函数会立即执行。
  - promise状态改变后的reject是异步执行的

一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称回调地狱。

- promise是用来解决两个问题的：


​	（1）回调地狱，代码难以维护，常常第一个的函数的输出是第二个函数的输入

​	（2）promise可以支持多个并发的请求，获取并发请求中的数据

注：这个promise可以解决异步的问题，本身不能说promise是异步的

**Promise基本用法**

```js
var promise = new Promise((resolve,reject) => {
    if (操作成功) {
        resolve(value)
    } else {
        reject(error)
    }
})
promise.then(function (value) {
    // success
},function (value) {
    // failure
})
```

**Promise.all用法**

（1）只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变成 fulfilled ,此时 p1 、 p2 、 p3 的返回值组成一个数组，传递给 p 的回调函数。 

（2）只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ,此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。 

```js
// promise all使用
const p1 = new Promise((resolve, reject) => {
    resolve()
}).then(result => console.log(result))

const p2 = new Promise((resolve, reject) => {
    reject()
}).then(result => console.log(result))

Promise.all([p1, p2])
    .then(function (result) {
    //
}).catch(error => error)
```

**Promise.race**

只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那 个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数

```js
 const p = Promise.race([p1, p2, p3]);
```

**手写Promise**

```js
function myPromise(constructor){
    let self=this;
    self.status="pending" //定义状态改变前的初始状态
    self.value=undefined;//定义状态为resolved的时候的状态
    self.reason=undefined;//定义状态为rejected的时候的状态
    function resolve(value){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.value=value;
          self.status="resolved";
       }
    }
    function reject(reason){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.reason=reason;
          self.status="rejected";
       }
    }
    //捕获构造异常
    try{
       constructor(resolve,reject);
    }catch(e){
       reject(e);
    }
}

//同时，需要在myPromise的原型上定义链式调用的then方法：
myPromise.prototype.then=function(onFullfilled,onRejected){
   let self=this;
   switch(self.status){
      case "resolved":
        onFullfilled(self.value);
        break;
      case "rejected":
        onRejected(self.reason);
        break;
      default:       
   }
}

var p=new myPromise(function(resolve,reject){resolve(1)});
p.then(function(x){console.log(x)})
//输出1
```

## 遍历的几种方式

- `for...in`遍历输出的是对象自身的属性以及原型链上可枚举的属性(不含Symbol属性),原型链上的属性最后输出说明先遍历的是自身的可枚举属性,后遍历原型链上的
- `Object.keys()`遍历对象返回的是一个包含对象自身可枚举属性的数组(不含Symbol属性).
-  `Objcet.getOwnPropertyNames()` 输出对象自身的可枚举和不可枚举属性的数组,不输出原型链上的属性

```js
// 1. for in
for (var i in arr) {

}

// 2. for each
array.forEach(element => {

});

// 3. map
arr.map((value, index, array) => {

})

// 4. Object.keys
Object.keys(obj)
Object.keys(obj).forEach(function () {

})
// 5. Object.getOwnPropertyNames
Object.getOwnPropertyNames(obj).forEach(function () {

})
// 6. some 只要有一个满足就返回
arr.some(function(value,index,array){
    return xxx
})
// 7. every  必须所有的都满足才返回 
arr.every(function(value,index,array){
    return xxx
})
// 8. reduce
arr.reduce(function(pre,cur,index,array){
    // array——原数组
	// prev——上一次调用回调时的返回值，或者初始值init
	// cur——当前正在处理的数组元素
	// index——当前正在处理的数组元素的索引
	// init——初始值
},init)
//数组求和
var sum = arr.reduce(function (prev, cur) {
    return prev + cur;
},0);
// 9. filter 筛选数组中满足条件的元素，返回一个筛选后的新数组
arr.filter(function(value,index,array){
    return xxx
})
```

## Event Loop

[面试题：说说事件循环机制(满分答案来了) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904079353708557#heading-1)

[详解JavaScript中的Event Loop（事件循环）机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33058983)

- JS是**单线程**的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将**同步代码**压入**执行栈**中，依次执行。
- 当异步事件结果返回时，会将**异步代码**推入**异步（事件）队列**。异步队列又分为宏任务队列和微任务队列**，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，**Promise.then**，MutationObserver，宏任务的话就是setImmediate **setTimeout setInterval
- 整个执行过程，我们称为**事件循环过程**。

js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。

以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。

- 以下事件属于宏任务：

  - `setInterval()`
  - `setTimeout()`

  以下事件属于微任务

  - `new Promise()`
  - `new MutaionObserver()`

我们只需记住**当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行**。

## 原型与原型链

### 原型 [prototype]

1. 函数的`prototype`属性

- 每个函数都有一个prototype属性, 它默认指向一个Object空的实例对象(即称为: 原型对象)
- 原型对象中有一个属性constructor, 它指向函数对象

2. 给原型对象添加属性(`一般都是方法`)

- 作用: 函数的所有实例对象自动拥有原型中的属性(方法)

```js
// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
console.log(Date.prototype, typeof Date.prototype)
function Fun () { }
console.log(Fun.prototype)  // 默认指向一个Object空对象(没有我们的属性)

// 原型对象中有一个属性constructor, 它指向函数对象
console.log(Date.prototype.constructor===Date)
console.log(Fun.prototype.constructor===Fun)

//给原型对象添加属性(一般是方法) ===>实例对象可以访问
Fun.prototype.test = function () { console.log('test()') }
var fun = new Fun()
fun.test()
```

### 显式原型与隐式原型

```js
//定义构造函数
  function Fn() {
   // 内部默认执行语句: this.prototype = {}
    }
  // 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象
  console.log(Fn.prototype)
  // 2. 每个实例对象都有一个__proto__，可称为隐式原型
  //创建实例对象                       
  var fn = new Fn()  // 内部默认执行语句: this.__proto__ = Fn.prototype
  console.log(fn.__proto__)
  // 3. 对象的隐式原型的值为其对应构造函数的显式原型的值
  console.log(Fn.prototype===fn.__proto__) // true
  //给原型添加方法
  Fn.prototype.test = function () {
    console.log('test()')
  }
  //通过实例调用原型的方法
  fn.test()
```

1. 每个函数function都有一个`prototype`，即`显式`原型(属性)
2. 每个实例对象都有一个[`__ proto __`]，可称为`隐式`原型(属性)
3. 对象的隐式原型的值为其对应构造函数的显式原型的值
4. 内存结构

![image-20220223205834139](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220223205834139.png)

![image-20220224000245496](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220224000245496.png)

5. 总结:

- 函数的[`prototype`]属性: 在定义函数时自动添加的, 默认值是一个空Object对象
- 对象的[`__ proto __`]属性: 创建对象时自动添加的, `默认值为构造函数的prototype属性值`
- 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)

6. 不好理解的点：

- 函数的显式原型执行的对象默认是空的Object实例对象（但Object不满足）

```js
console.log(Fn.prototype instanceof Object)//true
console.log(Object.prototype instanceof Object)//false
console.log(Function.prototype instanceof Object)//true
```

- 所有函数都是Function的实例，包括他本身。Function 是它自身的实例

```js
console.log(Function.__proto__ === Function.prototype)//true
```

- Object的原型对象是原型链的尽头

```js
Object.prototype.__proto__ = null
```

7. 代码示例

```js
//定义构造函数
  function Fn() {
   // 内部默认执行语句: this.prototype = {}
    }
  // 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象
  console.log(Fn.prototype)
  // 2. 每个实例对象都有一个__proto__，可称为隐式原型
  //创建实例对象
  var fn = new Fn()  // 内部默认执行语句: this.__proto__ = Fn.prototype
  console.log(fn.__proto__)
  // 3. 对象的隐式原型的值为其对应构造函数的显式原型的值
  console.log(Fn.prototype===fn.__proto__) // true
  //给原型添加方法
  Fn.prototype.test = function () {
    console.log('test()')
  }
  //通过实例调用原型的方法
  fn.test()
```

### 原型链

##### ①原型链

 - 访问一个对象的属性时，
  - 先在自身属性中查找，找到返回
   - 如果没有, 再沿着[`__ proto __`]这条链向上查找, 找到返回
  - 如果最终没找到, 返回undefined

   - 别名: 隐式原型链
   - 作用: 查找对象的属性(方法)

##### ②构造函数/原型/实例对象的关系(图解)


 ps:所有函数的[`__ proto __`]都是一样的，都是Function的prototype

##### ③ 属性问题

 - 读取对象的属性值时: 会自动到原型链中查找
 - 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值
 - 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上
 - 代码示例

```js
  function Fn() { }
  Fn.prototype.a = 'xxx'
  var fn1 = new Fn()
  console.log(fn1.a, fn1) //xxx Fn{}

  var fn2 = new Fn()
  fn2.a = 'yyy'
  console.log(fn1.a, fn2.a, fn2) //xxx yyy  Fn{a: "yyy"}

  function Person(name, age) {
    this.name = name
    this.age = age
  }
//属性在构造函数里面
//方法在原型链上
  Person.prototype.setName = function (name) {
    this.name = name
  }
  var p1 = new Person('Tom', 12)
  p1.setName('Bob')
  console.log(p1)  //Person {name: "Bob", age: 12}

  var p2 = new Person('Jack', 12)
  p2.setName('Cat')
  console.log(p2) //Person {name: "Cat", age: 12}
  console.log(p1.__proto__===p2.__proto__) // true   -->所以方法一般定义在原型中
```

#### instanceof

1. instanceof是如何判断的?

- 表达式: A instanceof B
- 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false

2. Function是通过new自己产生的实例

```js
/*案例1*/
 function Foo() {  }
 var f1 = new Foo()
 console.log(f1 instanceof Foo) // true
 console.log(f1 instanceof Object) // true

 /*案例2*/
 console.log(Object instanceof Function) // true
 console.log(Object instanceof Object) // true
 console.log(Function instanceof Function) // true
 console.log(Function instanceof Object) // true

 function Foo() {}
 console.log(Object instanceof  Foo) // false
```

### 面试题

```js
/*
 测试题1
  */
 function A () {}
 A.prototype.n = 1
 let b = new A()
 A.prototype = { n: 2, m: 3}
 let c = new A()
 console.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3
```

![image-20220226153501462](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220226153501462.png)

```js
/*测试题2*/
 function F (){}
 Object.prototype.a = function(){
   console.log('a()')
 }
 Function.prototype.b = function(){
   console.log('b()')
 }
 
   
 f.a() //a()
 f.b() //f.b is not a function -->找不到
 F.a() //a()
 F.b() //b()

 console.log(f)
 console.log(Object.prototype)
 console.log(Function.prototype)
```

## 箭头函数中this指向举例

```js
var a=11;
function test2(){
  this.a=22;
  let b=()=>{console.log(this.a)}
  b();
}
var x=new test2();
//输出22
//函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
```

## JS实现继承

首先创建一个父类

```js
// 定义一个动物类
function Animal(name, color) {
    // 属性
    this.name = name || 'Animal';
    this.color = color || ['black'];
    // 实例方法
    this.sleep = function () {
        console.log(this.name + '正在睡觉！');
    }
}
// 原型方法
Animal.prototype.eat = function (food) {
    console.log(this.name + '正在吃：' + food);
};
```

### 原型链继承

new了一个空对象，这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。

```js
function Cat(name) {
    this.name = name || 'tom'
}
Cat.prototype = new Animal()

var cat = new Cat()
cat.color.push('red')
cat.sleep() //tom正在睡觉！
cat.eat('fish') //tom正在吃：fish
console.log(cat.color) //["black", "red"]
console.log(cat instanceof Animal) //true
console.log(cat instanceof Cat) //true
var new_cat = new Cat()
console.log(new_cat.color) //["black", "red"]
```

- 特点：基于原型链，既是父类的实例，也是子类的实例。
- 缺点：1.无法实现多继承；2.所有新实例都会共享父类实例的属性。

### 构造继承

```js
function Dog(name) {
    Animal.call(this)
    this.name = name || 'mica'
}
var dog = new Dog()
dog.color.push('blue')
dog.sleep() // mica正在睡觉！
dog.eat('bone') //Uncaught TypeError: dog.eat is not a function
console.log(dog.color) //["black", "blue"]
console.log(dog instanceof Animal) //false
console.log(dog instanceof Dog) //true
var new_dog = new Dog()
console.log(new_dog.color) //["black"]
```

- 特点：可以实现多继承（call多个），解决了所有实例共享父类实例属性的问题。
- 缺点：1.只能继承父类实例的属性和方法；2.不能继承原型上的属性和方法。

### 组合继承

```js
function Mouse(name){
    Animal.call(this)
    this.name = name || 'jerry'
}
Mouse.prototype = new Animal()
Mouse.prototype.constructor = Mouse

var mouse = new Mouse()
mouse.color.push('yellow)
mouse.sleep() //jerry正在睡觉！
mouse.eat('carrot') //jerry正在吃：carrot
console.log(mouse instanceof Animal)//true
console.log(mouse instanceof Mouse)//true
var new_mouse = new Mouse()
console.log(new_mouse.color) //["black"]
```

- 特点：可以继承实例属性/方法，也可以继承原型属性/方法
- 缺点：调用了两次父类构造函数，生成了两份实例

## ES5继承和ES6继承的区别

ES5是上述实现的继承：通过原型和构造函数实现继承

ES6是通过关键字class定义类，通过关键字extends实现继承，子类必须在constructor方法中调用super() 方法，否则创建实例报错. 因为子类没有this对象, 而是使用父类的this, 然后对其进行加工。

```js
// ES6的继承
// 在子类的构造器中先调用super(), 创建出父类实例, 然后再去修改子类中的this去完善子类
class Parent {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
}

class Child extends Parent {
    constructor(a, b, c) {
        super(a, b);
        this.c = c;
    }
}

const child = new Child(1, 2, 3);
console.log(child); // { a: 1, b: 2, c: 3 }
```

## TypeScript 和 JavaScript

- TypeScript 是 JavaScript 的类型的超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等；
- 是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误；
- 同时扩展了JavaScript 的语法，所以任何现有的JavaScript 程序可以不加改变的在 TypeScript 下工作；
- 为了保证兼容性，typescript在编译阶段需要编译器编译成纯Javascript来运行，是为大型应用之开发而设计的语言

## ES6特性

1. 块级作用域 关键字let, 常量const

2. Promise

3. 解构赋值

5. 箭头函数 Arrow functions

6. 字符串模板 Template strings

7. Iterators（迭代器）+ for..of

8. 生成器 （Generators）

9. 类class

10. Modules

​	ES6的内置模块功能借鉴了CommonJS和AMD各自的优点：

11. Map + Set + WeakMap + WeakSet

四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。

12. Proxies

使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。

## ...运算符

```js
let arr1 = [1,3,5,7,9]
let arr2 = [2,4,6,8,10]
console.log(...arr1); //展开一个数组
let arr3 = [...arr1,...arr2]//连接数组

//在函数中使用
function sum(...numbers){
    return numbers.reduce((preValue,currentValue)=>{
        return preValue + currentValue
    })
}
console.log(sum(1,2,3,4));

//构造字面量对象时使用展开语法
let person = {name:'tom',age:18}
//复制一个对象
let person2 = {...person}
//console.log(...person); //报错，展开运算符不能展开对象
person.name = 'jerry'
console.log(person2);
console.log(person);

//合并
let person3 = {...person,name:'jack',address:"地球"}
console.log(person3);

```

# 三 浏览器

## HTTP

> 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种[网络协议](https://so.csdn.net/so/search?q=网络协议&spm=1001.2101.3001.7020),所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

| 版本     | 产生时间 | 内容                                                         | 发展现状           |
| -------- | -------- | ------------------------------------------------------------ | ------------------ |
| HTTP/1.0 | 1996年   | 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令 | 正式作为标准       |
| HTTP/1.1 | 1997年   | 持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码   | 2015年前使用最广泛 |
| HTTP/2   | 2015年   | **多路复用**、服务器推送、头信息压缩、二进制协议等           | 逐渐覆盖市场       |

- 请求行：请求方法，URL(**包括参数信息**)，协议版本这些信息（GET /admin_ui/rdx/core/images/close.png HTTP/1.1）
- 请求头
  - Accept：客户端用于接受哪些类型的信息。text/html 
  - Accept-Encoding：Accept-Encoding与Accept类似，它用于指定接受的编码方式
  - Connection：Keep-alive Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。
  - Content-Type：请求的数据格式一般为json。这时就需要设置`Content-Type: application/json`。
- 请求文：当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。

## HTTP缓存

缓存规则分为**强制缓存**和**协商缓存**

- HTTP属于客户端缓存，我们常认为浏览器有一个缓存数据库，用来保存一些静态文件，下面我们分为以下几个方面来简单介绍HTTP缓存
- 缓存分为强缓存和协商缓存 。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。

**1. 强缓存**

当缓存数据库中有客户端需要的数据，客户端直接将数据从其中拿出来使用（如果数据未失效），当缓存服务器没有需要的数据时，客户端才会向服务端请求。

对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。

**Expires**

Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。

**Cache-Control**

Cache-Control有很多属性，不同的属性代表的意义也不同。

- private：客户端可以缓存
- public：客户端和代理服务器都可以缓存
- max-age=t：缓存内容将在t秒后失效
- no-cache：需要使用协商缓存来验证缓存数据
- no-store：所有内容都不会缓存。

![image-20220314141951861](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220314141951861.png)

2. **协商缓存**

- Last-Modified 和 If-Modified-Since
- Etag 和 If-None-Match

又称对比缓存。客户端会先从缓存数据库拿到一个缓存的标识，然后向服务端验证标识是否失效，如果没有失效服务端会返回304，这样客户端可以直接去缓存数据库拿出数据，如果失效，服务端会返回新的数据

![image-20220314142202947](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220314142202947.png)

强制缓存的优先级高于协商缓存，若两种缓存皆存在，且强制缓存命中目标，则协商缓存不再验证标识。

协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。

**Last-Modified**

> Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。

- `if-Modified-Since`:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。

从字面上看，就是说：从某个时间节点算起，是否文件被修改了

- 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
- 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified
- `if-Unmodified-Since`:从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改
  - 如果没有被修改:则开始`继续'传送文件: 服务器返回: 200 OK
  - 如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)

这两个的区别是一个是修改了才下载一个是没修改才下载。

Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

**Etag**

> Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

- If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。
  - 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
  - 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。

**缓存的优点**

- 减少了冗余的数据传递，节省宽带流量
- 减少了服务器的负担，大大提高了网站性能
- 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。

## HTTP1.1  HTTP1.0  HTTP2.0

> [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 - _浪潮之巅.☆ - 博客园 (cnblogs.com)](https://www.cnblogs.com/heluan/p/8620312.html)

- HTTP1.0：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接
- HTTP1.1：
  - **引入了持久连接**，即TCP连接默认不关闭，可以被多个请求复用：**在HTTP1.1中默认开启Connection： keep-alive**，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
  - **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, **If-Match, If-None-Match**等更多可供选择的缓存头来控制缓存策略。
  - **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在**请求头引入了range头域**，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
  - **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
  - **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
  - 在同一个TCP连接里面，客户端可以同时发送多个请求
  - 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
  - 新增了一些请求方法
  - 新增了一些请求头和响应头
- HTTP2.0：
  - 采用**二进制格式**进行协议解析而非文本格式
  - 完全**多路复用**，而非有序并阻塞的、只需一个连接即可实现并行。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
  - 使用**报头压缩**，降低开销
  - **服务器推送**：例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。

## HTTP与HTTPS的区别

- 基本概念：
  - http:（超文本传输协议） 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
  - https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：**建立一个信息安全通道，来确保数据的传输，确保网站的真实性。**
- HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的 SSL 加密传输协议
- HTTP的URL由`http://`起始且默认使用端口80，而HTTPS的URL由`https://`起始且默认使用端口443
- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全
- https `缓存`不如 http 高效，会增加数据开销。
- http 的连接很简单，是无状态的。https 握手阶段比较`费时`，会使页面加载时间延长 50%，增加 10%~20%的耗电

## HTTP状态码

**1xx表示客户端应该继续发送请求**

**2xx表示成功的请求**

- 200表示OK，正常返回信息
- 201表示请求成功且服务器创建了新的资源
- 202表示服务器已经接受了请求，但还未处理

**3xx表示重定向**

- 301表示永久重定向，请求的网页已经永久移动到新位置
- 302表示临时重定向
- 304表示自从上一次请求以来，页面的内容没有改变过

**4xx表示客户端错误**

- 401表示服务器无法理解请求的格式
- 402表示请求未授权
- 403表示禁止访问
- 404表示请求的资源不存在，一般是路径写错了

**5xx表示服务器错误**

- 500表示最常见的服务器错误
- 503表示服务器暂时无法处理请求

## TCP 三次握手四次挥手

> [tcp建立连接为什么需要三次握手 - 简书 (jianshu.com)](https://www.jianshu.com/p/e7f45779008a)
>
> [史上最详细的经典面试题 从输入URL到看到页面发生了什么？ - 掘金 (juejin.cn)](https://juejin.cn/post/6844903832435032072#heading-26)

### TCP 三次握手的过程

![3 次握手.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d65b93d07fd74758a60a0ecb9c117200~tplv-k3u1fbpfcp-watermark.awebp)

- **第一次握手**：

  客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；

- **第二次握手**：

  服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

- **第三次握手**：

  客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

  握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

**为什么三次挥手**

为了**防止已经失效的连接请求报文段突然又传到服务端，因而产生错误**。

这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。

**哪一次最容易被攻击**

TCP三次握手在第二阶段容易受到攻击，即syn溢出攻击，如果客户机伪造出大量第一次的sys同步报文，服务端就会依次消耗掉很多资源来保存客户端的信息，并进行确认，实际上确认是会失败的，但失败需要一定的时间，因为服务端会连续多次进行第二次握手确认后才认定失败。那么短时间有大量的sys同步报文涌向服务端，服务端资源可能被耗尽，就可能导致正常的客户端得不到响应而失败。


### TCP四次握手

![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a12c33ac8d04fec8f21eb5c4fc482ab~tplv-k3u1fbpfcp-watermark.awebp)

**第一次挥手**：

客户端发送一个FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可 以接受数据。 FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

**第二次挥手**：

服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

**第三次挥手**：

服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

**第四次挥手**：

主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

- TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。
- 最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。

**四次握手的状态转换**

** FIN_WAIT_1 ** 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态；

** FIN_WAIT_2 ** 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN；

** TIME_WAIT ** 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN；

** CLOSING ** 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态；

** CLOSE_WAIT ** 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送；

** LAST_ACK ** 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态；

** CLOSED ** 这个状态表示连接已经断开。

**为什么四次握手**

本质的原因是tcp是**全双公**的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，**但是此时A还是可以接收数据，B也可以发送数据**；当**B发出FIN报文的时候此时两边才会真正的断开连接，读写分开**。

**为什么等待2MSL**

- 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
- 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

**为什么建立连接是三次握手，关闭连接确是四次挥手呢？**

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

## 几种请求方法

GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE

## get和post区别

| 请求方式       | GET                                | POST                       |
| -------------- | ---------------------------------- | -------------------------- |
| 参数位置       | 参数拼接到url的后面                | 参数在请求体中             |
| 参数大小       | 受限于浏览器url大小，一般不超过32K | 1G                         |
| 服务器数据接收 | 接收1次                            | 根据数据大小，可分多次接收 |
| 适用场景       | 从服务器端获取数据                 | 向服务器提交数据           |
| 安全性         | 参数携带在url中，安全性低          | 相对于GET请求，安全性更高  |
| TCP数据包个数  | 1个                                | 2个                        |

详细的说就是：

- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
- 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。
- 注意一点，并不是所有的浏览器都会发送两次数据包，Firefox就发送一次

## URL输入到浏览器解析的一系列事件

- DNS解析
- 发起TCP连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束。

## DNS解析

DNS解析其实是一个递归的过程

输入`www.google.com`网址后，首先在本地的域名服务器中查找，没找到去根域名服务器查找，没有再去`com`顶级域名服务器查找，，如此的类推下去，直到找到IP地址，然后把它记录在本地，供下次使用。大致过程就是`. `-> .com ->` google.com.` -> `www.google.com.`。 (你可能觉得我多写 .，并木有，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上)

**DNS优化**

既然已经懂得了解析的具体过程，我们可以看到上述一共经过了N个过程，每个过程有一定的消耗和时间的等待，因此我们得想办法解决一下这个问题！

**DNS缓存**

DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

- 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。
- 系统缓存主要存在/etc/hosts(Linux系统)中

## 浏览器渲染机制

1. 构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node
2. 构建渲染树（construct）：解析对应的CSS样式文件信息
3. 布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；
4. 绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。

详细解释：

 （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。

 （2）然后对 CSS 进行解析，生成 CSSOM 规则树。

 （3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

 （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

 （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

## 重绘和重排的区别

**重绘（repaint或redraw）**：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局）

**重排（重构/回流/reflow）**：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。

触发重排的条件：任何页面布局和几何属性的改变都会触发重排：

- 页面渲染初始化(无法避免)
- 添加或删除可见的DOM元素
- 元素位置的改变，或者使用动画
- 元素尺寸的改变——大小，外边距，边框
- 浏览器窗口尺寸的变化
- 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变

重排必定会引发重绘，但重绘不一定会引发重排。

## 如何解决跨域

> [什么是跨域请求以及实现跨域的方案 - 简书 (jianshu.com)](https://www.jianshu.com/p/f880878c1398)

#### 同源策略

1. 什么是同源？

   域名、协议、端口有一个不同就不是同源，三者均相同，这两个网站才是同源

2. 浏览器为什么需要同源策略

​		同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。

1. CORS

2. jsonp：

    在网页有一些标签天生具有跨域能力，比如: img link iframe script

    JSONP就是利用**script标签的跨域能力**来发送请求的。

3. 服务器代理

更多CORS请看[彻底读懂前端跨域CORS](https://link.juejin.cn?target=http%3A%2F%2Fxieyufei.com%2F2019%2F08%2F29%2FCors.html)

[AJAX](D:\Typora_makedown\字节前端面试准备\AJAX.md)

## JSONP原理

由于浏览器的同源策略限制，不允许跨域请求；但是页面中的 script、img、iframe标签是例外，不受同源策略限制。

Jsonp 就是利用`script`标签跨域特性进行请求。

JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好一个同名回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数。

JSONP缺点：它只支持`GET`请求，而不支持`POST`请求等其他类型的HTTP请求。

首先当前页面中声明有这样的一个函数，它将作为 JSONP 的回调函数处理作为函数参数传入的数据

```html
<script type="text/javascript">
    function dosomething(jsondata){
        //处理获得的json数据
    }
</script>
```

然后，我们就可以借助 `<script><img><iframe>` 等标签可以引入不同域资源的特性，将需要发送的请求的路径作为src参数，其中需要注意的是：需要告知服务端回调函数的函数名。

```html
<script src="http://example.com/data.php?callback=dosomething"></script>
```

这时服务端在返回数据的时候，就会返回一端 Javascript 代码，在 Javascript代码中调用了回调函数，并且需要返回的数据作为回调函数的参数

```js
dosomething(['a','b','c']);
```

最后页面成功加载了刚才指定路径的资源后，将会执行该 Javascript 代码，`dosomething`函数将执行，这时一次跨域请求完成。

## CORS

1.CORS是什么?

**CORS(Cross-Origin Resource Sharing),跨域资源共享**。CORS是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求。跨域资源共享标准新增了一组**HTTP首部字段**，允许服务器声明哪些源站通过浏览器有权限访问哪些资源

2.CORS怎么工作?

**CORS是通过设置一个响应头来告诉浏览器，该请求允许跨域**，浏览器收到该响应以后就会对响应执行。

3.CORS的使用

https://blog.csdn.net/qq22692150/article/details/99011726?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control

案例

html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORS</title>
    <script crossorigin="anonymous" src="https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.js"></script>
    <style>
        #result{
            width:200px;
            height:100px;
            border:solid 1px #90b;
        }
    </style>
</head>
<body>
    <button>发送请求</button>
    <div id="result"></div>
    <script>
        const btn = document.querySelector('button');
        const result = document.getElementById('result');
        btn.onclick = function(){
           axios({
               method: 'GET',
               url: 'http://localhost:8000/cors-server',
           }).then(response =>{
                result.innerHTML = response.data;
           })
        }
    </script>
</body>
</html>

```

server.js

```js
//1. 引入express
const express = require('express');

//2. 创建应用对象
const app = express();

//3. 创建路由规则
// request 是对请求报文的封装
// response 是对响应报文的封装
//jsonp服务
app.all('/jsonp-server',(request, response) => {
});
//用户名检测是否存在
app.all('/check',(request, response) => {
});

app.all('/jquery-jsonp',(request, response) => {
});
app.all('/cors-server', (request, response)=>{
    //设置响应头
    //所有页面都可以跨域访问
    response.setHeader("Access-Control-Allow-Origin", "*");
    //允许发送任意请求头，可以是自定义的
    response.setHeader("Access-Control-Allow-Headers", '*');
    //请求方法任意
    response.setHeader("Access-Control-Allow-Method", '*');
    // response.setHeader("Access-Control-Allow-Origin", "http://127.0.0.1:5500");
    response.send('hello CORS');
});


//4. 监听端口启动服务
app.listen(8000, () => {
    console.log("服务已经启动, 8000 端口监听中....");
});
```

## XSS和CSRF区别

> [Web 安全之 XSS 和 CSRF - Jartto's blog](http://jartto.wang/2017/12/15/xss-and-csrf/)

1. 明确xss和csrf是什么
2. 明确xss和csrf攻击的特点
3. 如何防范xss和csrf

#### **XSS 跨站脚本攻击**（Cross Site Scripting)

为了不和层叠样式表 CSS 混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往 Web 页面里插入恶意 Script 代码（js，html），当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。

1. XSS 主要有如下[三种分类](https://juejin.im/post/59e6b21bf265da43247f861d)：

   - **Reflected XSS**（基于**反射**的 XSS攻击）：是指xss代码在请求的url中，而后提交到服务器，服务器解析后，XSS代码随着响应内容一起传给客户端进行解析执行。（直接反射显示在页面）

   - **Stored XSS**（基于**存储**的 XSS攻击）：Stored XSS和 Reflected XSS的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，**从而获得了在网络上传播的能力。**

   - **DOM-based or local XSS**（基于DOM或本地的 XSS 攻击）：DOM型 XSS其实是一种特殊类型的反射型 XSS，它是基于 DOM文档对象模型的一种漏洞。可以通过 DOM来动态修改页面内容，从客户端获取 DOM中的数据并在本地执行。基于这个特性，就可以利用 JS脚本来实现 XSS漏洞的利用。

2. 防御措施：服务端和客户端在发送数据的时候都要进行一下过滤，例如`URL`、查询关键字、`HTTP`头、`POST`数据等

#### 跨站请求伪造（Cross-site request forgery）

跨站伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

要完成一次 `CSRF` 攻击，受害者必须依次完成两个步骤：

1. 登录受信任网站 `A`，并在本地生成 `Cookie`。
2. 在不登出 `A` 的情况下，访问危险网站 `B`。

**防御措施：**

1. 主要在服务器端做的防御
2. 验证 `HTTP Referer` 字段（根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址），利用 `HTTP` 头中的 `Referer` 判断请求来源是否合法。
3. 在请求地址中添加 `token` 并验证，在请求中放入黑客所不能伪造的信息，并且该信息不存在于 `cookie` 之中，以`HTTP` 请求参数的形式加入一个随机产生的 `token` 交由服务端验证。

**区别：**

- 原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注入JS代码，然后执行JS里的代码。
- CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
- CSRF的目标是用户，XSS的目标是服务器
- XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求

**总结：**

1. 明确xss和css是什么，可以举两个例子，最后谈一下怎么防御

![image-20220319103119318](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220319103119318.png)



## fetch和axios

<img src="C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220319001246782.png" alt="image-20220319001246782" style="zoom:80%;" />

**1.fetch是规范底层的api**

**2.axios是封装**

**3.fetch和axios的优缺点**

#### fetch

```js
fetch('http://example.com/movies.json')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson) {
    console.log(myJson);
  });
```

**fetch的优势**

1. 语法简介，更加语义化
2. 基于Promise实现，支持async/await
3. 更加底层，提供的API丰富
4. 脱离了XHR，是ES规范里新的实现方式

**fetch的问题**

fetch是一个**低层次的API**，可以考虑成原生的XHR

1. 当接收到一个代表错误的 HTTP 状态码时，从 `fetch()`返回的 Promise **不会被标记为 reject，** 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 `ok` 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。
2. 默认情况下，`fetch` **不会从服务端发送或接收任何 cookies**, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 [credentials](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FGlobalFetch%2Ffetch%23%E5%8F%82%E6%95%B0) 选项）。自从2017年8月25日后，默认的credentials政策变更为`same-origin`Firefox也在61.0b13中改变默认值
3. 不支持abort，不支持超时控制

#### axios

```js
// 可选地，上面的请求可以这样做
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

Axios是一个基于Promise（ES6中用于处理异步的）的HTTP库，用于**浏览器和node.js**中，[API](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kancloud.cn%2Fyunye%2Faxios%2F234845)。

- 浏览器中创建XMLHttpRequests
- 提供了一些并发请求的接口
- 从node.js中创建http请求
- 支持Promise API
- 拦截请求和响应
- 转换请求数据和响应数据
- 取消请求
- 自动转换JSON数据（fetch 需要手动处理返回的数据）
- 客户端支持防御CSRF。

#### 回答思路

明确fetch和axios分别是什么？然后说明各自的优缺点

![image-20220319003455668](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220319003455668.png)

## 多个标签页之间的通信

> 文章开始之前我先解释一下什么是浏览器标签页面之间通信，通俗点讲就是我在浏览器中开了多个窗口，在其中一个窗口做了一些行为等其它的窗口不用刷新也能有相关表现。比如我在浏览器开一个商品信息窗口，一个购物车窗口，我在商品信息窗口某个商品上点击加入购物车，购物车窗口中就自动多出一个商品，不用去手动刷新，这就是两个标签页面之间的通信，那么怎么实现呢？有四种方式(我目前就知道这么多)，接下来我就一一演示并详细解释其原理。
>
> 实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。
>
> [(29条消息) 实现浏览器内多个标签页面之间通信的四种方法_Love——金哥哥的博客-CSDN博客_如何实现浏览器内多个标签页之间的通信?](https://blog.csdn.net/weixin_46399753/article/details/105211771)

#### **localstorage**

我们可以在一个标签页对 **localStorage 的变化事件进行监听**，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。

localStorage比cookie好在它在**setItem存东西时会自动触发整个浏览器的storage事件**，除了当前页面之外，所有打开的标签窗口都会受影响。那我们来看一下用localStorage怎么实现。

```html
<!-- send.html -->
<body style="text-align: right">
  <input id="msg1" type="text"> 
  <input id="msg2" type="text"> 
  <button id="send">发送</button>
  <script>
    send.onclick = function(){
      if(msg1.value.trim()!=="" && msg2.value.trim()!==""){
        localStorage.setItem("msg1",msg1.value.trim());
        localStorage.setItem("msg2",msg2.value.trim());
      }
    }
  </script>
</body>
```

![image-20220319004757127](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220319004757127.png)

```html
<!-- receive.html -->
<body>
  <h1>收到消息：<span id="recMsg"></span></h1>
  <script>
    function load(){
      recMsg.innerHTML = localStorage.getItem("msg1");
    }
    load();
    // 任何页面修改了localStorage的值，都会自动触发其他页面中的storage事件
    // 只要storage一变化我们读取localStorage中对应的值显示到页面上
    window.addEventListener("storage",function(){
      load();
    });
  </script>
</body>
```

**总结**

- 缺点：1、localStorage是h5的属性，高版本的浏览器才支持，而且不同浏览器localStorage大小了限制不统一。2、localStorage只能监听非己页面的数据变化。
- 优点：解决了cookie容量小和时效性的问题。

#### **cookie + setInterval方式**

```js
document.cookie = "name"+name//发送的页面
setInterval//不停的取数据
getCookie("name")//接受的页面
```

- 首先要想在多个窗口中通信，通信的内容一定不能放在window对象中，因为window是当前窗口的作用域，里面的内容只以属于当前窗口。有一种方式就是放在cookie中，cookie是浏览器的本地存储机制，和窗口无关，存在于硬盘上都可以读取。接下来我们就来演示一下。现在还有一个问题，在send页面发送消息receive页面不能实时更新，需要手动刷新。我们可以用setInterval定时器解决，
- 缺点：
  - cookie空间有限，浏览器在每一个域名下最多能设置30-50个cookie，容量最多为4k左右。
  - 每次HTTP请求才会把当前域的cookie发送到服务器上，包括只在本地才用到的而服务器不用的，浪费带宽。
  - setInterval频率设置过大会影响浏览器的性能，过小会影响时效性。
- 优点：每个浏览器都兼容

#### **websocket全双工**

- websocket 协议，全双工，服务器可以主动给浏览器发数据，浏览器也可以给服务器发数据。

- **send.html发送消息到WebSocketServer，WebSocketServer再实时把消息发给receive.html，其实这就是实时通信的原理（微信、qq、淘宝旺旺等）**

- 缺点：

  1、它需要服务端的支持才能完成任务。如果socket数据量比较大的话，会严重消耗服务器的资源。
  2、必须要在服务端项目中写服务端监听程序才能支持。

- 优点：使用简单（客户端简单，服务端苦逼了），功能灵活、强大，如果部署了WebSocket服务器，可以实现很多实时的功能。

```html
<!-- send.html文件 -->
<body style="text-align: right">
  <input id="msg" type="text"> 
  <button id="send">发送</button>
  <script>
    //建立到服务端webSocket连接
    var ws = new WebSocket("ws://localhost:8080");
    send.onclick = function(){
      if(msg.value.trim()!==""){
        // 将消息发到服务器
        ws.send(msg.value.trim());
      }
    }
  </script>
</body>

<!-- receive.html文件 -->
<body>
  <h1>收到消息：<span id="recMsg"></span></h1>
  <script>
    //建立到服务端webSocket连接
    var ws = new WebSocket("ws://localhost:8080");
    //当连接被打开时，注册接收消息的处理函数
    ws.onopen=function(event) {
      //当有消息发过来时，就将消息放到显示元素上
      ws.onmessage=function(event) {
        recMsg.innerHTML=event.data;
      }
    }
  </script>
</body>
```

#### **SharedWorker**

- WebWorker的升级版，WebWorker只能在一个窗口内使用，而现在我们需求是多个窗口之间通信，就要用SharedWorker了。
- SharedWorker原理和WebWorker几乎是一样的，只不过SharedWorker可以跨多个页面使用。
- SharedWorker也是纯客户端的，没有服务端的参与。
- SharedWorker在客户端有一个自己维护的对象**worker.js**，消息存储在worker.js中的data中
- SharedWorker不如localStorage的是接收消息不是自动的，也要用定时器实时从worker.js中获取

![image-20220319100452686](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220319100452686.png)

## 多个网站之间共享登录状态

在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将页面重定向会单点登录页面。

## CDN

- CDN 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度
- CDN 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速
- 通过CDN的负载均衡系统，智能调度边缘节点提供服务，相当于CDN服务的大脑，而缓存系统相当于CDN的心脏，缓存命中直接返回给用户，否则回源

# 四、性能优化

前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。

第一个方面是页面的内容方面

 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。

 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。

 （3）通过设置缓存策略，对常用不变的资源进行缓存。

 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。

 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

第二个方面是服务器方面

 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。

 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。

 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

第三个方面是 CSS 和 JavaScript 方面

 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。

 （2）避免使用 @import 标签。

 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。

 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。

- 使用CDN
- gzip压缩
- 文本压缩
- 合并请求
- 雪碧图
- 图片懒加载
- 缓存资源
- 减少DOM操作

> PS：看到评论区好多同学批评我说整理得太简单了，react，webpack，Promise都没有，怎么能算面试题呢？首先感谢大家的评论，我会更加努力整理深入的知识点，其次，前端的东西多而杂，我整理这篇文章花了大概一个月时间，有些基础的知识点我可能工作了一段时间都没有用到过，所以偏向基础一点，请技术大佬忽略本文。

# 五 React

## 组件

### 函数式组件

1. 创建函数式组件

- 这是一个函数 但是没有被我们调用，是React帮助我们调用的
- this？ undefined 是由于babel编译后开启了严格模式，严格模式下禁止自定义函数下的this指向	windows
- 定义函数式组件的时候要用大写！
- 函数必须要有返回值

2. 执行了ReactDOM之后发生了什么

   - React解析组件标签，找到了MyComponent组件

   - 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM 转为真实DOM，随后呈现在页面中

```js
function Demo() {
    return <h2>我是函数定义的组件</h2>
    console.log(this)
}
// 渲染组件到页面
/* 
        执行了ReactDOM之后发生了什么
        1. React解析组件标签，找到了MyComponent组件
        2. 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM 转为真实DOM，随后呈现在页面中
         */
ReactDOM.render(<Demo />, document.getElementById('test'))
```

### class组件

```js
//必须继承React.Component
//然后重写Render()方法，该方法一定要有返回值，返回一个虚拟DOM
//this 指向的是MyComponent的实例对象 组件实例对象
class MyComponent extends React.Component {
    render() {
        return <h2>我是复杂组件</h2>
    }
}
ReactDOM.render(<MyComponent/>,document.getElementById('test'))
```

执行过程：

 **1.React解析组件标签，找到相应的组件**

 **2.发现组件是类定义的，随后new出来的类的实例，并通过该实例调用到原型上的render方法**

 **3.将render返回的虚拟DOM转化为真实的DOM,随后呈现在页面中**

**复杂组件和简单组件：是否有状态state，组件的状态里面存放的数据，数据的改变会影响真实的DOM，状态是组件实例对象上面的**

### 组件的三大属性

#### state

**理解：**

1.state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)

2.组件被称为"状态机", 通过更新组件的state来更新对应的页面显示(重新渲染组件)

**强烈注意：**

1. 组件中**render方法中的this为组件实例对象**

2. 组件**自定义的方法中this为undefined**，如何解决？

​		a)   强制绑定this: 通过函数对象的bind()

​		b)   **箭头函数**

3. 状态数据，**不能直接修改或更新，要借助setState**

#### Props ——保存标签属性(只读)

**props基本使用**

```js
//创建组件
		class Person extends React.Component{
			render(){
				// console.log(this);
				const {name,age,sex} = this.props
				return (
					<ul>
						<li>姓名：{name}</li>
						<li>性别：{sex}</li>
						<li>年龄：{age+1}</li>
					</ul>
				)
			}
		}
		//渲染组件到页面
		ReactDOM.render(<Person name="jerry" age={19}  sex="男"/>,document.getElementById('test1'))
		ReactDOM.render(<Person name="tom" age={18} sex="女"/>,document.getElementById('test2'))

		const p = {name:'老刘',age:18,sex:'女'}
		// console.log('@',...p);
		// ReactDOM.render(<Person name={p.name} age={p.age} sex={p.sex}/>,document.getElementById('test3'))
		ReactDOM.render(<Person {...p}/>,document.getElementById('test3'))
```

**对标签属性做限制**

```jsx
Person.propTypes = {
    name: PropTypes.string.isRequired, //限制name必传，且为字符串
    sex: PropTypes.string,//限制sex为字符串
    age: PropTypes.number,//限制age为数值
    speak: PropTypes.func,//限制speak为函数
}
//指定默认标签属性值
Person.defaultProps = {
    sex: '男',//sex默认值为男
    age: 18 //age默认值为18
}
```

#### refs

**字符串形式的refs**

```html
<input ref="input1" type="text" placeholder="点击按钮提示数据" />&nbsp;
const { input1 } = this.refs
```

**回调函数形式的refs**

```html
<input ref={c => this.input1 = c} type="text" placeholder="点击按钮提示数据" />&nbsp;
```

**createRef**

```html
<input ref={this.myRef} type="text" placeholder="点击按钮提示数据"/>&nbsp;
<input onBlur={this.showData2} ref={this.myRef2} type="text" placeholder="失去焦点提示数据"/>&nbsp;
myRef = React.createRef()
myRef2 = React.createRef()
```

- 发生事件的结点和操作的结点是一个的时候，可以省略refs

### 非受控组件和受控组件

## 生命周期

**理解**

- 组件从创建到死亡它会经历一些特定的阶段。
- React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。
- 我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。

**旧生命周期的总结**

![image-20220315224025037](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220315224025037.png)

**1.** **初始化阶段:** 由ReactDOM.render()触发---**初次渲染**

- constructor()
- componentWillMount()
- render()
- **componentDidMount()**：常用
  - 组件挂载完毕的钩子
  - 一般在这个钩子中做一些初始化的事情：例如开启定时器、发送网络请求、订阅消息

​    **2.** **更新阶段:** 由**组件内部this.setState()**或**父组件重新render触发**

- shouldComponentUpdate()
- componentWillUpdate()
- **render()**：常用
- componentDidUpdate()

​    **3.** **卸载组件:** **由ReactDOM.unmountComponentAtNode()触发**

-  **componentWillUnmount()**：常用
   - 一般在这个钩子中做一些收尾的事情：例如：关闭定时器、取消订阅消息

 **新生命周期流程图**

>  新旧对比：
>
> 1. 废弃三个
> 2. 新提出两个：这两个不咋用

![image-20220316001114310](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220316001114310.png)

**1.** **初始化阶段:** 由ReactDOM.render()触发---初次渲染

- constructor()
- **getDerivedStateFromProps** 
- render()
- componentDidMount()

**2.** **更新阶段:** 由组件内部this.setSate()或父组件重新render触发

1. getDerivedStateFromProps
2. shouldComponentUpdate()
3. render()
4. **getSnapshotBeforeUpdate**
5. componentDidUpdate()

**3.** **卸载组件:** 由ReactDOM.unmountComponentAtNode()触发

​	componentWillUnmount()

**重要的钩子**

1. render：初始化渲染或更新渲染调用
2. componentDidMount：开启监听, 发送ajax请求
3. componentWillUnmount：做一些收尾工作, 如: 清理定时器

## diff算法

经典面试题:

- react/vue中的key有什么作用？（key的内部原理是什么？）
- 为什么遍历列表时，key最好不要用index?

​        1. 虚拟DOM中key的作用：

​          1). 简单的说: key是虚拟DOM对象的**标识**, 在**更新**显示时key起着极其重要的作用。

​          2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 

​                        随后React进行【新虚拟DOM】与【旧虚拟DOM】的**diff比较**，比较规则如下：

​                  a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：

​                        (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM

​                        (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM

​                  b. 旧虚拟DOM中未找到与新虚拟DOM相同的key

​                        根据数据创建新的真实DOM，随后渲染到到页面

​      2. 用index作为key可能会引发的问题：

​                1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:

​                        会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

​                2. 如果结构中还包含输入类的DOM：

​                        会产生错误DOM更新 ==> 界面有问题。

​                3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，

​                  仅用于渲染列表用于展示，使用index作为key是没有问题的。

​      3. 开发中如何选择key?

​                1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。

​                2.如果确定只是简单的展示数据，用index也是可以的。

## Router

**什么是路由**?

> 1. 一个路由就是一个映射关系(key:value)
> 2. key为路径, value可能是function或component

##### 前端路由

> 1. 浏览器端路由，value是component，用于展示页面内容。
> 2. 注册路由: `<Route path="/test" component={Test}>`
> 3. 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件

**react-router-dom的理解**

①相关概念

> 1. react的一个插件库。
> 2. 专门用来实现一个SPA应用。
> 3. 基于react的项目基本都会用到此库。

②相关api

内置组件

> 1. `<BrowserRouter>`
> 2. `<HashRouter>`
> 3. `<Route>`
> 4. `<Redirect>`
> 5. `<Link>`
> 6. `<NavLink>`
> 7. `<Switch>`

其他

> 1. history对象
> 2. match对象
> 3. withRouter函数

**路由的基本使用**

> 1.明确好界面中的导航区、展示区
>
> 2.导航区的a标签改为Link标签
>
> ```
> <Link to="/xxxxx">Demo</Link>
> ```
>
> 3.展示区写Route标签进行路径的匹配
>
> ```
> <Route path='/xxxx' component={Demo}/>
> ```
>
> 4.`<App>`的最外侧包裹了一个`<BrowserRouter>或<HashRouter>`
>
> ```jsx
> ReactDOM.render(
> <BrowserRouter>
> 	<App/>
> </BrowserRouter>,
> document.getElementById('root')
> )
> ```

## BrowserRouter与HashRouter的区别

> 备注：HashRouter可以用于解决一些路径错误相关的问题。即在`问题6`中引入文件时可以不进行路径修改

**Ⅰ-底层原理不一样：**

> 1. BrowserRouter使用的是**H5的history API**，不兼容IE9及以下版本。
>
> 2. HashRouter使用的是URL的哈希值。/#/a/b/c/d  #后面的资源不会发送给服务器但是可以形成历史记录

**Ⅱ-path表现形式不一样**

> 1. BrowserRouter的路径中没有#,例如：localhost:3000/demo/test
> 2. HashRouter的路径包含#,例如：localhost:3000/#/demo/test

**Ⅲ-刷新后对路由state参数的影响**

> 1. **BrowserRouter没有任何影响，因为state保存在history对象中。**
> 2. **HashRouter刷新后会导致路由state参数的丢失！！！**

**Ⅳ HashRouter可以解决一些路径错误相关的问题** 

# Redux

### 1、redux理解

**Ⅰ-学习文档**

> 1. 英文文档: [https://redux.js.org/](https://gitee.com/link?target=https%3A%2F%2Fredux.js.org%2F)
> 2. 中文文档: [http://www.redux.org.cn/](https://gitee.com/link?target=http%3A%2F%2Fwww.redux.org.cn%2F)
> 3. Github: [https://github.com/reactjs/redux](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Freactjs%2Fredux)

**Ⅱ-redux是什么**

> 1. redux是一个专门用于做`状态管理的JS库`(不是react插件库)。
> 2. 它可以用在react, angular, vue等项目中, 但基本与react配合使用。
> 3. 作用: 集中式管理react应用中多个组件`共享`的状态。

**Ⅲ-什么情况下需要使用redux**

> 1. 某个组件的状态，需要让其他组件可以随时拿到（共享）。
> 2. 一个组件需要改变另一个组件的状态（通信）。
> 3. 总体原则：能不用就不用, 如果不用比较吃力才考虑使用。

**Ⅳ-redux工作流程**

> ![React系统学习_Redux工作流程原理图](https://gitee.com/hongjilin/hongs-study-notes/raw/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0/A_React%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/React%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_Redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86%E5%9B%BE.png)

### 2、redux的三个核心概念

**Ⅰ-action**

> 1. `动作的对象`
>
> 2. 包含2个属性
>
>    type：标识属性, 值为字符串, 唯一, 必要属性
>
>    data：数据属性, 值类型任意, 可选属性
>
> 3. 例子：{ type: 'ADD_STUDENT',data:{name: 'tom',age:18} }

**Ⅱ-reducer**

> 1. 用于初始化状态、加工状态。
> 2. 加工时，根据旧的state和action， 产生新的state的`纯函数(以下为纯函数概念)``
>
> - ``纯函数:`一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)
> - 必须遵守以下一些约束
>   1. 不得改写参数数据
>   2. 不会产生任何副作用，例如网络请求，输入和输出设备
>   3. 不能调用Date.now()或者Math.random()等不纯的方法
>
> 3. `redux的reducer函数必须是一个纯函数`

**Ⅲ-store**

> 1. 将state、action、reducer联系在一起的对象
> 2. `如何得到此对象`?
>    - import {createStore} from 'redux'
>    - import reducer from './reducers'
>    - const store = createStore(reducer)
> 3. 此对象的功能?
>    - getState(): 得到state
>    - dispatch(action): 分发action, 触发reducer调用, 产生新的state
>    - subscribe(listener): 注册监听, 当产生了新的state时, 自动调用

## Hooks

> 详见隔壁文件夹`React Hooks`笔记

**1. React Hook/Hooks是什么?**

> (1). Hook是React 16.8.0版本增加的新特性/新语法 
>
> (2). 可以让你在函数组件中使用 state 以及其他的 React 特性

**2. 三个常用的Hook**

> (1). State Hook: React.useState()   
>
> (2). Effect Hook: React.useEffect()
>
> (3). Ref Hook: React.useRef()

**3. State Hook**

> (1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作
>
> (2). 语法: const [xxx, setXxx] = React.useState(initValue)
>
> (3). useState()说明: 参数: 第一次初始化指定的值在内部作缓存 返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数
>
> (4). setXxx()2种写法: setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值 setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值

**4. Effect Hook**

> (1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子) (2). React中的副作用操作: 发ajax请求数据获取 设置订阅 / 启动定时器 手动更改真实DOM (3). 语法和说明: useEffect(() => { // 在此可以执行任何带副作用操作 return () => { // 在组件卸载前执行 // 在此做一些收尾工作, 比如清除定时器/取消订阅等 } }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行
>
> (4). 可以把 useEffect Hook 看做如下三个函数的组合 componentDidMount() componentDidUpdate() componentWillUnmount()

**5. Ref Hook**

> (1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据 (2). 语法: const refContainer = useRef() (3). 作用:保存标签对象,功能与React.createRef()一样
>
> ```js
> myRef = React.createRef()
> show = ()=>{
> 	alert(this.myRef.current.value)
> }
> ```

## React事件绑定

react常见的绑定方式有如下：

- ​    render方法中使用bind
- ​    render方法中使用箭头函数
- ​    constructor中bind
- ​    定义阶段使用箭头函数绑定

前两种方式在每次组件render的时候都会生成新的方法实例，性能问题欠缺

>  待整理:
>
> [总结了17年初到18年初百场前端面试的面试经验(含答案) - 掘金 (juejin.cn)](https://juejin.cn/post/6844903636271644680)
>
> [面试分享：两年工作经验成功面试阿里P6总结 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903928442667015)
>
> [web前端面试总结(自认为还算全面哈哈哈哈哈！！！！） - 掘金 (juejin.cn)](https://juejin.cn/post/6844903976693940231)

## hooks用过吗？聊聊react中class组件和函数组件的区别

类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 `props` 对象并返回一个React元素。

关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较"轻"，而类比较"重"。而且，钩子是函数，更符合 React 函数式的本质。

函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。

类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。

**类组件的缺点** :

大型组件很难拆分和重构，也很难测试。
 业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。
 组件类引入了复杂的编程模式，比如 render props 和高阶组件。
 难以理解的 class，理解 JavaScript 中 `this` 的工作方式。

**区别**：

函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。

1.状态的有无
 hooks出现之前，函数组件`没有实例`，`没有生命周期`，`没有state`，`没有this`，所以我们称函数组件为无状态组件。 hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。

2.调用方式的不同
 函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。

3.因为调用方式不同，在函数组件使用中会出现问题
 在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值

**React Hooks（钩子的作用）**

*Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。

React Hooks的几个常用钩子:

1. `useState()` //状态钩子
2. `useContext()` //共享状态钩子
3. `useReducer()` //action 钩子
4. `useEffect()` //副作用钩子

还有几个不常见的大概的说下，后续会专门写篇文章描述下

- 1.useCallback 记忆函数 一般把**函数式组件理解为class组件render函数的语法糖**，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。

  ```js
  function App() {
    const memoizedHandleClick = useCallback(() => {
      console.log('Click happened')
    }, []); // 空数组代表无论什么情况下该函数都不会发生改变
    return <SomeComponent onClick={memoizedHandleClick}>Click Me</SomeComponent>;
  }
  复制代码
  ```

  第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。

- 2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：**useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你**。
   所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。

- 3.useRef 保存引用值

  useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值**访问组件或真实的 DOM 节点，重点是组件也是可以访问到的**，从而可以对 DOM 进行一些操作，比如监听事件等等。

- 4.useImperativeHandle 穿透 Ref

  通过 useImperativeHandle 用于让父组件获取子组件内的索引

- 5.useLayoutEffect 同步执行副作用

  大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。

  **useEffect和useLayoutEffect有什么区别**：简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。`官方建议优先使用useEffect`

## React 组件通信方式

react组件间通信常见的几种情况:

- 父组件向子组件通信
- 子组件向父组件通信
- 跨级组件通信
- 非嵌套关系的组件通信

#### 1）父组件向子组件通信

父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用props就可以获取到这个值

```js
// 子组件: Child
const Child = props =>{
  return <p>{props.name}</p>
}

// 父组件 Parent
const Parent = ()=>{
    return <Child name="京程一灯"></Child>
}
复制代码
```

#### 2）子组件向父组件通信

props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过props调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值

```js
// 子组件: Child
const Child = props =>{
  const cb = msg =>{
      return ()=>{
          props.callback(msg)
      }
  }
  return (
      <button onClick={cb("京程一灯欢迎你!")}>京程一灯欢迎你</button>
  )
}

// 父组件 Parent
class Parent extends Component {
    callback(msg){
        console.log(msg)
    }
    render(){
        return <Child callback={this.callback.bind(this)}></Child>    
    }
}
复制代码
```

#### 3）跨级组件通信

即父组件向子组件的子组件通信，向更深层子组件通信。

- 使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。
- 使用context，context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。

```js
// context方式实现跨级组件通信 
// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据

const BatteryContext = createContext();

//  子组件的子组件 
class GrandChild extends Component {
    render(){
        return (
            <BatteryContext.Consumer>
                {
                    color => <h1 style={{"color":color}}>我是红色的:{color}</h1>
                }
            </BatteryContext.Consumer>
        ) 
    }
}

//  子组件
const Child = () =>{
    return (
        <GrandChild/>
    )
}
// 父组件
class Parent extends Component {
      state = {
          color:"red"
      }
      render(){
          const {color} = this.state
          return (
          <BatteryContext.Provider value={color}>
              <Child></Child>
          </BatteryContext.Provider> 
          )
      }
}
复制代码
```

#### 4）非嵌套关系的组件通信

即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。

- 可以使用自定义事件通信（发布订阅模式），使用pubsub-js
- 可以通过redux等进行全局状态管理
- 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。
- 也可以new一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE的eventBus 就是发布订阅模式，是可以在React中使用的;

## setState 既存在异步情况也存在同步情况

1.异步情况 在`React事件当中是异步操作`

2.同步情况 如果是在`setTimeout事件或者自定义的dom事件`中，都是同步的

```js
//setTimeout事件
import React,{ Component } from "react";
class Count extends Component{
    constructor(props){
        super(props);
        this.state = {
            count:0
        }
    }

    render(){
        return (
            <>
                <p>count:{this.state.count}</p>
                <button onClick={this.btnAction}>增加</button>
            </>
        )
    }
    
    btnAction = ()=>{
        //不能直接修改state，需要通过setState进行修改
        //同步
        setTimeout(()=>{
            this.setState({
                count: this.state.count + 1
            });
            console.log(this.state.count);
        })
    }
}

export default Count;
复制代码
//自定义dom事件
import React,{ Component } from "react";
class Count extends Component{
    constructor(props){
        super(props);
        this.state = {
            count:0
        }
    }

    render(){
        return (
            <>
                <p>count:{this.state.count}</p>
                <button id="btn">绑定点击事件</button>
            </>
        )
    }
    
    componentDidMount(){
        //自定义dom事件，也是同步修改
        document.querySelector('#btn').addEventListener('click',()=>{
            this.setState({
                count: this.state.count + 1
            });
            console.log(this.state.count);
        });
    }
}

export default Count;
```

## 说一下 react-fiber

#### 1）背景

react-fiber 产生的根本原因，是`大量的同步计算任务阻塞了浏览器的 UI 渲染`。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用`setState`更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。

#### 2）实现原理

- react内部运转分三层：
  - Virtual DOM 层，描述页面长什么样。
  - Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。
  - Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。

`Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示`：

```js
const fiber = {
    stateNode,    // 节点实例
    child,        // 子节点
    sibling,      // 兄弟节点
    return,       // 父节点
}
复制代码
```

- 为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：
  - synchronous，与之前的Stack Reconciler操作一样，同步执行
  - task，在next tick之前执行
  - animation，下一帧之前执行
  - high，在不久的将来立即执行
  - low，稍微延迟执行也没关系
  - offscreen，下一次render时或scroll时才执行
- Fiber Reconciler（react ）执行过程分为2个阶段：
  - 阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。
  - 阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。
- Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。

从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情

传送门 ☞[# 深入了解 Fiber](https://juejin.cn/post/7002250258826657799)

# 六 手写代码

## 数组扁平化

方法一：用reduce实现数组扁平化

```js
//用reduce实现数组扁平化
function flat(arr) {
    return arr.reduce((pre, cur) => {
        // pre是上次函数执行后返回的值
        return pre.concat((Array.isArray(cur)) ? flat(cur) : cur)
    }, [])
}
```

> [JS数组reduce()方法详解及高级技巧 - 简书 (jianshu.com)](https://www.jianshu.com/p/e375ba1cfc47)

①语法：

```js
arr.reduce(callback,[initialValue])
```

reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。

```
callback （执行数组中每个值的函数，包含四个参数）

    1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
    2、currentValue （数组中当前被处理的元素）
    3、index （当前元素在数组中的索引）
    4、array （调用 reduce 的数组）

initialValue （作为第一次调用 callback 的第一个参数。）
```

②实例解析 initialValue 参数

先看第一个例子：

```js
var arr = [1, 2, 3, 4];
var sum = arr.reduce(function(prev, cur, index, arr) {
    console.log(prev, cur, index);
    return prev + cur;
})
console.log(arr, sum);
//打印结果：
//1 2 1
//3 3 2
//6 4 3
//[1, 2, 3, 4] 10
```

这里可以看出，上面的例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。

再看第二个例子：

```js
var  arr = [1, 2, 3, 4];
var sum = arr.reduce(function(prev, cur, index, arr) {
    console.log(prev, cur, index);
    return prev + cur;
}，0) //注意这里设置了初始值
console.log(arr, sum);
//打印结果：
0 1 0
1 2 1
3 3 2
6 4 3
[1, 2, 3, 4] 10
```

这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。

结论：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。

③reduce的简单用法

当然最简单的就是我们常用的数组求和，求乘积了。

```js
var  arr = [1, 2, 3, 4];
var sum = arr.reduce((x,y)=>x+y)
var mul = arr.reduce((x,y)=>x*y)
console.log( sum ); //求和，10
console.log( mul ); //求乘积，24
```

④reduce的高级用法

（1）计算数组中每个元素出现的次数

```js
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];

let nameNum = names.reduce((pre,cur)=>{
  if(cur in pre){
    pre[cur]++
  }else{
    pre[cur] = 1 
  }
  return pre
},{})
console.log(nameNum); //{Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}
```

（2）数组去重

```js
let arr = [1,2,3,4,4,1]
let newArr = arr.reduce((pre,cur)=>{
    if(!pre.includes(cur)){
      return pre.concat(cur)
    }else{
      return pre
    }
},[])
console.log(newArr);// [1, 2, 3, 4]
```

（3）将二维数组转化为一维

```js
let arr = [[0, 1], [2, 3], [4, 5]]
let newArr = arr.reduce((pre,cur)=>{
    return pre.concat(cur)
},[])
console.log(newArr); // [0, 1, 2, 3, 4, 5]
```

（4）将多维数组转化为一维

```js
let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
const newArr = function(arr){
   return arr.reduce((pre,cur)=>pre.concat(Array.isArray(cur)?newArr(cur):cur),[])
}
console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]
```

二：使用concat+...扩展运算符

```js
 function flatten(arr) {
        var result = []
        //some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。
        while (arr.some(Array.isArray)) {
            result = result.concat(...arr)
            arr = result
            result = []
            console.log(arr)
        }
        return result
    }
```

方法二：直接使用flat()

> [9. 数组的扩展 - 数组实例的 flat()，flatMap() - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack](https://www.bookstack.cn/read/es6-3rd/spilt.9.docs-array.md)

```js
a.flat(3)
//flat的参数表示打平几层
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]
[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
```

## 数组去重复

**方法一：使用indexof**

indexof可以返回数组中的数据的位置，遍历数组如果发现indexof不等于-1，则该元素重复

```js
// 方法一：使用indexOf
function unique1(array) {
    if (!Array.isArray(array)) {
        console.log('error!')
        return
    }
    var result = []
    array.forEach(element => {
        if (result.indexOf(element) === -1) result.push(element)
    });
    return result
} 
```

**方法二：使用sort**

sort可以对数组进行排序，将排序后的数组，从前遍历，和周围的元素比较，如果两两不等，则说明这个元素不重复

sort是按照 Unicode 位点排序，如果要实现正常的排序结果

```js
const arr = [49, 5, 14, 89, 71, 3, 10];

// 一般写法
arr.sort(function (a, b) {
    return a - b;   // 按照升序排列 
});

// 箭头函数
arr.sort((a, b) => a - b);

// 结果  [3, 5, 10, 14, 49, 71, 89
//以上是按照升序排列的写法，如果要按照降序排列，只需把比较函数中的 return a - b; 改为 return b - a;。
```

```js
// 方法二：sort
function unique2(array) {
    if (!Array.isArray(array)) {
        console.log('error!')
        return
    }
    var result = []
    arr = array.sort()
    // console.log(arr)
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] !== arr[i + 1]) result.push(arr[i])
    }
    return result
}
```

**方法三：构造一个对象，保存数组元素出现的个数**

```js
// 方法三：对象
function unique3(arr) {
    if (!Array.isArray(arr)) {
        console.log('error!')
        return
    }
    var obj = {}
    var result = []
    for (var i = 0; i < arr.length; i++) {
        if (!obj[arr[i]]) {
            result.push(arr[i])
            obj[arr[i]] = 1
        }
        else obj[arr[i]]++
    }
    return result
}
```

**方法四：使用Set**

```js
// 方法四：set
function unique4(arr) {
    if (!Array.isArray(arr)) {
        console.log('error!')
        return
    }
    return ([...new Set(arr)])
}
//Set 对象允许你存储任何类型的唯一值  Set中的元素只会出现一次，即 Set 中的元素是唯一的。
/* mySet.add(1); // Set [ 1 ]
mySet.add(5); // Set [ 1, 5 ]
mySet.add(5); // Set [ 1, 5 ]
mySet.add("some text"); // Set [ 1, 5, "some text" ]
let o = {a: 1, b: 2};
mySet.add(o);

mySet.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题

mySet.has(1); // true
mySet.has(3); // false
mySet.has(5);              // true
mySet.has(Math.sqrt(25));  // true
mySet.has("Some Text".toLowerCase()); // true
mySet.has(o); // true

mySet.size; // 5

mySet.delete(5);  // true,  从set中移除5
mySet.has(5);     // false, 5已经被移除

mySet.size; // 4, 刚刚移除一个值

console.log(mySet); 
logs Set(4) [ 1, "some text", {…}, {…} ] in Firefox
logs Set(4) { 1, "some text", {…}, {…} } in Chrome*/

```

**方法五：使用Set() + Array.from**

```js
// 方法五：set+from(将set转化为数组)
function unique5(arr) {
    if (!Array.isArray(arr)) {
        console.log('error!')
        return
    }
    return (Array.from(new Set(arr)))
    //Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。
    //Array.from() 方法的返回值是一个新的数组实例。
    //Array.from() 方法可以从String   Set    Map生成数组
}
```

## 数组扁平化、去重、排序

```js
// 扁平化
const flattenDeep = (array) => array.flat(Infinity)

// 去重
const unique = (array) => Array.from(new Set(array))

// 排序
const sort = (array) => array.sort((a, b) => a-b)

// 函数组合
const compose = (...fns) => (initValue) => fns.reduceRight((y, fn) => fn(y), initValue)

// 组合后函数
const flatten_unique_sort = compose( sort, unique, flattenDeep)

// 测试
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]
console.log(flatten_unique_sort(arr))
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

## 用setTimeout 实现setInterval

```js
function mySetTimeout (func,time) {
	function interval() {
		setTimeout(interval,time)
		func()
	}
	interval()
}
```

## 手写apply

```js
Function.prototype.myCall = function (content = windows) {
    content.fn = this
    var args = [...arguments].slice(1)
    console.log(arguments, args)
    var result = content.fn(...args)
    delete content.fn
    return result
}
let foo = {
    value: 1
}
function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}
bar.myCall(foo, 'black', '18') // black 18 1
```

## 手写call

```js
//  简单版
var foo = {
	value:1
	bar: function () {
	console.log(this.value)
	}
}
foo.bar()

//复杂版
Function.prototype.call2 = function (content = window) {
    // 把bar看成一个实例对象
    // call在Function的原型上 这样call2 就成为了bar 的方法，可以调用
    // this 就指向调用call2的那个原型  
    // 在这题中   this 就是bar
    // 首先获取this   就是这个bar函数
    console.log(this)
    // 然后把这个函数添加到content 的方法上，成为content 的一个属性
    content.fn = this;
    // 传递参数
    let args = [...arguments].slice(1);
    // result就是函数调用的结果了
    let result = content.fn(...args);
    // 把函数从content 的属性删掉
    delete content.fn;
    // 返回函数处理结果
    return result;
}
let foo = {
    value: 1
}
function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}
bar.call2(foo, 'black', '18') // black 18 1
```

## 实现一个new

```js
function myNew(func) {
    var p = {}
    var args = [...arguments].slice(1)
    if (func.prototype !== null)
        p.__proto__ = func.prototype
    var ret = func.apply(p, args)
    if ((typeof (ret) === "Object" || typeof (ret) === "function") && ret !== null)
        return ret
    return p
}

function Test(name, age) {
    this.name = name
    this.age = age
}
Test.prototype.sayName = function () {
    console.log(this.name)
}

var p = myNew(Test, "小红", 18)
console.log(p.name, p.age)
p.sayName()
```

## 实现一个instanceof

```js
function myInstanceOf(A, B) {
    var proto = A.__proto__
    var prototype = B.prototype
    while (true) {
        console.log(proto)
        if (proto === null) return false
        if (proto === prototype) return true
        aproto = proto.__proto__
    }
}

function B(name, age) {
    this.name = name
    this.age = age
}
function C(name, age) {
    this.name = name
    this.age = age
}
var A = new B("小红", 19)
var AA = new C("小红", 19)
console.log(myInstanceOf(A, B), myInstanceOf(AA, B))
```

## 1234567 变成RMB形式 即 1,234,567

```js
// 1234567 变成RMB形式 即 1,234,567
var str = "12345678"
function numToRMB(str) {
    // Array.from 将字符串转化为数组
    var res = []
    // 这里还可以用split转化为数组
    var nums = Array.from(str).reverse()
    for (var i in nums) {
        if ((i + 1) % 3 === 0)
            res.push(',')
        res.push(nums[i])
    }
    return res.reverse().join('')
}
var RMB = numToRMB(str)
console.log(RMB)
```

## [1, [2, [3, [4, null]]]] 转化成 [ 4, [ 3, [ 2, [1,null] ] ] ]

```js
//不一定对。。。。 
var nums = [1, [2, [3, [4, null]]]]
nums = nums.flat(Infinity)
// console.log(nums)
function qiantao(nums) {
    var res = []
    if (nums.length <= 0) return
    res[0] = nums.pop()
    res[1] = nums.length === 0 ? null : qiantao(nums)
    // console.log(res)
    return res
}
var a = qiantao(nums)
console.log(a)
```

## Excel 表列名称

```js
var convertToTitle = function(columnNumber) {
    var res = []
    while(columnNumber > 0) {
        columnNumber = columnNumber -1
        var m = (columnNumber % 26) 
        res.push(m+65)
        columnNumber = parseInt(columnNumber / 26)
        // console.log(columnNumber)
    }
    return String.fromCharCode(...res.reverse())
};
```

## 括号匹配

思路：栈  哈希表

[20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/valid-parentheses/)

# 七 项目

功能：在输入框里面输入一个 Figma 设计稿的链接。然后点击查找之后，下方的列表就会呈现 Figma 设计稿的相关信息。然后点击查看，就会跳转到 Figma 中对应的设计稿。然后点击转换按钮，然后列任务列表就会创建新，就会新建一个任务，然后并对设计稿进行转换。然后在任务列表我们点击查看代码，就可以查看设计稿的 HTML 和 CSS 代码以及相应的一个预览页面。

接下来是对前端组件的介绍。第一个是 mytypes 它是用于切换 Figma 转换页面和任务列表页面。第二个是 DTO C list 的组件，它包括 searchbox 和 task 两个子组件。 search box 用于查找 task 用于将查找的结果展示在这个表格中。这个是 task list 的组件，它是用于展示所有转换中以及转换完成的任务。这个是 code detail 组件，它是用于展示转换出来的 HTML 代码、 CSS 代码以及对应的页面图。其中用到了这个 code highlight 组件，它是用于对代码的高亮展示。像这样一样。

接下来是对前端接口的介绍，我们一共有四个接口，分别是查询转换任务列表以及展示代码。下面将对这几个接口的流程进行下介绍。第一个，查询接口，它的具体流程为获得获取用户输入的 Figma 的 ururl 发送 post 请求。 post 请求的内容。如这个图所示，成功收到 response 数据之后，转换数据的格式就是将有的数据转换成这样的图片以及按钮这样的格式。如果没有能成功收到 response 数据，则获得它的 error 信息，利用这些些数据或者是 error 信息更新 DTO C list 组件的 state 然后展示在页面上。

这里的 status 一共有 0123 种取值，分别表示未转换。转换中已完成三种任务状态。 status 等于 0 时，它这里就显示的是未开始转换，等于 1 时就显示已建立 DTO C 任务转换接口的流程和查询的其实类似的。也是 post 发送请求，然后后端返回 status 更新为 1 的数据。然后这里的转换按钮就会变为禁用状态，然后这里的状态变成已建立 DQC 任务。

最后一个部分是我们前端在开发过程中遇到的问题以及相应的解决方法。第一个我们是使用的字节跳动的 ACro design 组件库进行统一的开发。我们之前是没有接触过这个组件库，需要在官网上进行学习。不过学过学过之后，学过之后会发现上手很容易，然后操作也比较便捷。

我在项目中主要负责的是查询接口的完成。查询组件由input框和button构成。具体的流程是获取用户输入的url地址并通过axois发送post请求，得到post请求的响应内容response，data数据包括figma设计稿的id和task的id，thumbnail缩略图等等。转换数据的格式就是将现有的数据转换成缩略图以及按钮的格式等等，如果没有收到reponse数据，就获取error信息。利用这些信息更新D2CList组件的state 然后展示再界面上。更新组件的过程通过props完成



![image-20220319155712393](C:\Users\fy\AppData\Roaming\Typora\typora-user-images\image-20220319155712393.png)

```js
// 获取用户输入的url 并进行转换
	search = () => {
		//获取用户的输入(连续解构赋值+重命名)
		// 取得用户输入
		const value = this.keyWordElement.value
		console.log(value)
		//发送请求前通知D2CList更新状态
		this.props.updateListState({ tasks: [], isFirst: false, isLoading: true })
		//发送网络请求
		axios.post("http://localhost:8800/GetUrl", {
			figmaUrl: value,
		})
			// axios.get("data.json")
			.then((response) => {
				console.log(response)
				console.log(response.data)
				//请求成功后通知D2CList更新状态
				this.props.updateListState({ isLoading: false })
				this.props.updateListState({ tasks: this.convertdata(response.data) })
			}).catch((error) => {
				this.props.updateListState({ isLoading: false, err: error.message })
			})
	}
```

## axios拦截器怎么配

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});
// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });
```

面试官好。我叫方瑶，是一名来自北京大学软件与微电子学院的研究生。我的本科就读于中国农业大学。本科和研究生所学专业都是电子与通信。研一上通过学校和字节合作的D2C项目第一次接触到前端这项技术。通过项目，以及自己的学习，我对HTML,CSS,Javascript有了一定的了解，除此之外还接触到了一些React框架以及nodejs基础应用。我非常希望能够加入字节跳动，在实习过程中提升自己的前端技术，实现自己的价值。

